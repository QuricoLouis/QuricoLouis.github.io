<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QuricoLouis</title>
  
  <subtitle>QuricoLouisの博客</subtitle>
  <link href="http://quricolouis.github.io/atom.xml" rel="self"/>
  
  <link href="http://quricolouis.github.io/"/>
  <updated>2021-07-29T15:54:31.432Z</updated>
  <id>http://quricolouis.github.io/</id>
  
  <author>
    <name>QuricoLouis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人博客搭建</title>
    <link href="http://quricolouis.github.io/posts/e3e08109.html"/>
    <id>http://quricolouis.github.io/posts/e3e08109.html</id>
    <published>2019-08-27T03:41:03.000Z</published>
    <updated>2021-07-29T15:54:31.432Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="0x001-效果演示"><a href="#0x001-效果演示" class="headerlink" title="0x001 效果演示"></a>0x001 效果演示</h2><hr><p><img src="https://s2.ax1x.com/2020/03/11/8E3bBF.png" alt="演示Demo"></p><h2 id="0x002-简单介绍"><a href="#0x002-简单介绍" class="headerlink" title="0x002 简单介绍"></a>0x002 简单介绍</h2><hr><p>  前前后后大概花了一周多的时间，目前个人博客已经完善的差不多了，现在写个文章做个阶段总结，后续如果有更新的地方，会及时补充。本博客基于Hexo框架，采用<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery</a>主题，在这里非常感谢作者<code>洪卫</code>的<a href="https://github.com/shw2018/hexo-blog-fly.git">hexo-blog-fly</a>博客开源，极大简化了构建博客的工作量和复杂度。在此开源博客的基础上做了改进，修复了一些bug，顺利搭建完成了我的个人博客。大家对此主题有兴趣的可以<a href="https://github.com/shw2018/hexo-blog-fly">下载源代码</a>，搭建属于自己的个性化博客。</p><ul><li>个人博客 演示：<a href="http://luckyzmj.cn/">http://luckyzmj.cn</a></li></ul><hr><h2 id="0x003-Hexo-初级搭建"><a href="#0x003-Hexo-初级搭建" class="headerlink" title="0x003 Hexo 初级搭建"></a>0x003 Hexo 初级搭建</h2><hr><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h3><p><code>Git</code>是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。<code>Git</code>的作用是将本地的网页文件传到<code>github</code>上。</p><ul><li>Git<a href="https://git-scm.com/download">下载地址</a></li><li>Git<a href="https://www.liaoxuefeng.com/wiki/896043488029600">教程</a></li></ul><p><strong>windows：</strong> 到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>。</p><h3 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2. 安装node.js"></a>2. 安装node.js</h3><p><code>Hexo</code>是基于<code>node.js</code>编写的，所以需要安装一下<code>node.js</code>和里面的<code>npm</code>工具。</p><p><strong>windows：</strong> 到<a href="http://nodejs.cn/download/">Node.js官网</a>下载<code>.exe</code>文件，安装选项全部默认。安装好之后，按<code>Win+R</code>打开cmd命令提示符，输入<code>node -v</code>和<code>npm -v</code>，若出现版本号，则说明安装成功。</p><h3 id="3-添加npm国内源"><a href="#3-添加npm国内源" class="headerlink" title="3. 添加npm国内源"></a>3. 添加npm国内源</h3><p>使用阿里的国内镜像进行加速下载</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm config set registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-安装Hexo"><a href="#4-安装Hexo" class="headerlink" title="4. 安装Hexo"></a>4. 安装Hexo</h3><p>前面<code>git</code>和<code>nodejs</code>安装好后，就可以安装<code>hexo</code>了，你可以先创建一个文件夹<code>MyBlog</code>，用来存放自己的博客文件，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键<code>git bash</code>打开）。</p><p>比如我的博客文件都存放在<code>E:\MyBlog</code>目录下。</p><p>在该目录下右键点击<code>Git Bash Here</code>，打开<code>git</code>的控制台窗口，以后我们所有的操作都在<code>git</code>控制台进行，就不用<code>Windows</code>自带的<code>cmd</code>了。</p><p>定位到该目录下，输入<code>npm install -g hexo-cli</code>安装<code>Hexo</code>。可能会有几个报错，不用理会。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>到此为止<code>hexo</code>就安装完了。</p><p>接下来初始化一下<code>hexo</code>,即初始化我们的网站，输入<code>hexo init</code>初始化文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init MyBlog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建完成后，指定文件夹<code>MyBlog</code>目录下有：</p><ul><li><code>node_modules</code>: 依赖包</li><li><code>public</code>：存放生成的页面</li><li><code>scaffolds</code>：生成文章的一些模板</li><li><code>source</code>：用来存放你的文章</li><li><code>themes</code>：主题**</li><li><code>_config.yml</code>: 博客的配置文件**</li></ul><p>到此为止，本地的网站配置完成了。</p><p>输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2020/03/12/8VdlGD.png"></p><h3 id="5-注册Github账号创建个人仓库"><a href="#5-注册Github账号创建个人仓库" class="headerlink" title="5. 注册Github账号创建个人仓库"></a>5. 注册Github账号创建个人仓库</h3><p>接下来就去注册一个<code>github</code>账号，用来存放我们的网站。</p><p>打开<a href="https://github.com/">https://github.com/</a>，新建一个项目仓库<code>New repository</code>，如下所示：</p><p><img src="https://s1.ax1x.com/2020/03/12/8VwrtK.png"></p><p>然后如下图所示，输入自己的项目名字，后面一定要加<code>.github.io</code>后缀，README初始化也要勾上</p><p><img src="https://s1.ax1x.com/2020/03/12/8VdoQJ.png"></p><blockquote><p>要创建一个和你用户名相同的仓库，后面加<code>.github.io</code>，只有这样，将来要部署到<code>GitHub page</code>的时候，才会被识别，也就是<code>http://xxxx.github.io</code>，其中xxx就是你注册<code>GitHub</code>的用户名。例如我的：<code>http://LuckyZmj.github.io</code></p></blockquote><h3 id="6-生成SSH添加到GitHub"><a href="#6-生成SSH添加到GitHub" class="headerlink" title="6. 生成SSH添加到GitHub"></a>6. 生成SSH添加到GitHub</h3><p>生成<code>SSH</code>添加到<code>GitHub</code>，连接<code>Github</code>与本地。<br>右键打开<code>git bash here</code>，然后输入下面命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git config --global user.name "注册GitHub用户名"git config --global user.email "注册GitHub的邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>用以下两条，检查一下你有没有输对</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git config user.namegit config user.email<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后创建<code>SSH</code>,一路回车</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C "注册GitHub的邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候它会告诉你已经生成了<code>.ssh</code>的文件夹。在<code>git bash</code>中输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>打开<code>github</code>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code>，名字随便取一个都可以，把你的<code>id_rsa.pub</code>里面的信息复制进去。如图：</p><p><img src="https://s1.ax1x.com/2020/03/12/8Vwnyj.png"></p><p>在<code>git bash</code>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-将hexo部署到GitHub"><a href="#7-将hexo部署到GitHub" class="headerlink" title="7. 将hexo部署到GitHub"></a>7. 将hexo部署到GitHub</h3><p>将<code>hexo</code>生成的文章部署到<code>GitHub</code>上，打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。<br>找到如下配置进行修改：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: git  repository: https://github.com/LuckyZmj/LuckyZmj.github.io  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>repository</code>修改为你自己的<code>github</code>项目地址即可，就是部署时，告诉工具，将生成网页通过<code>git</code>方式上传到你对应的链接仓库中。</p><p>这个时候需要先安装<code>deploy-git</code> ，也就是部署的命令,这样你才能用命令部署到<code>GitHub</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后就可以部署提交到<code>github</code>，过一会儿就可以在<code>http://yourname.github.io</code> 这个网站看到你的博客了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中 <code>hexo clean</code>清除了你之前生成的东西。 <code>hexo generate</code>，生成静态文章，可以用 <code>hexo g</code>缩写 ，<code>hexo deploy</code>部署文章，可以用<code>hexo d</code>缩写</p><blockquote><p>注意<code>deploy</code>时可能要你输入<code>username</code>和<code>password</code>。</p></blockquote><h3 id="8-写文章和发布文章"><a href="#8-写文章和发布文章" class="headerlink" title="8. 写文章和发布文章"></a>8. 写文章和发布文章</h3><p>首先在博客根目录下右键打开<code>git bash here</code>，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后输入<code>hexo new post "article title"</code>，新建一篇文章。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new post "article title"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后打开<code>E:\MyBlog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件。</p><p>另外推荐直接使用<code>有道云</code>编写<code>markdown</code>文章，不仅可以实时预览，还可以快捷的生成<code>markdown</code>语法格式，具体效果如下图所示。</p><p><img src="https://s1.ax1x.com/2020/03/12/8VwItf.png" alt="有道云"></p><p>编写完<code>markdown</code>文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到<code>github</code>上。这时打开你的<code>github.io</code>主页就能看到发布的文章了。</p><p>到此为止，<code>Hexo</code>初级搭建就已经完成了。</p><h2 id="0x004-Hexo-优化定制"><a href="#0x004-Hexo-优化定制" class="headerlink" title="0x004 Hexo 优化定制"></a>0x004 Hexo 优化定制</h2><hr><h3 id="1-Hexo相关目录文件"><a href="#1-Hexo相关目录文件" class="headerlink" title="1. Hexo相关目录文件"></a>1. Hexo相关目录文件</h3><h4 id="1-1-博客目录构成介绍"><a href="#1-1-博客目录构成介绍" class="headerlink" title="1.1 博客目录构成介绍"></a>1.1 博客目录构成介绍</h4><p><code>node_modules</code>是<code>node.js</code>各种库的目录，<code>public</code>是生成的网页文件目录，<code>scaffolds</code>里面就三个文件，存储着新文章和新页面的初始设置，<code>source</code>是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件，<code>themes</code>存放着主题文件，一般也用不到。</p><p>我们平时写文章只需要关注<code>source/_posts</code>这个文件夹就行了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">- node_modules- public- scaffolds- source    - _data    - _posts    - about    - archives    - categories    - friends    - tags- themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-hexo基本配置"><a href="#1-2-hexo基本配置" class="headerlink" title="1.2 hexo基本配置"></a>1.2 hexo基本配置</h4><p>在文件根目录下的<code>_config.yml</code>，就是整<code>个hexo</code>框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的<a href="https://hexo.io/zh-cn/docs/configuration">配置描述</a>。</p><h5 id="1-2-1-网站"><a href="#1-2-1-网站" class="headerlink" title="1.2.1 网站"></a>1.2.1 网站</h5><p>参数描述<code>title</code>网站标题<code>subtitle</code>网站副标题<code>description</code>网站描述<code>author</code>您的名字<code>language</code>网站使用的语言<code>timezone</code>网站时区。<code>Hexo</code> 默认使用您电脑的时区。时区列表。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</p><p>其中，<code>description</code>主要用于<code>SEO</code>，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h5 id="1-2-2-网址"><a href="#1-2-2-网址" class="headerlink" title="1.2.2 网址"></a>1.2.2 网址</h5><p>参数描述<code>url</code>网址<code>root</code>网站根目录 <code>permalink</code>文章的<a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a>格式<code>permalink_defaults</code>永久链接中各部分的默认值</p><p>在这里，你需要把<code>url</code>改成你的网站域名。</p><p><code>permalink</code>，也就是你生成某个文章时的那个链接格式。</p><p>比如我新建一个文章叫<code>temp.md</code>，那么这个时候他自动生成的地址就是<code>http://yoursite.com/2018/09/05/temp</code>。</p><p>以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找<a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">参数结果:year/:month/:day/:title       /2019/08/10/hello-world :year-:month-:day-:title.html  2019-08-10-hello-world.html :category/:titlefoo            /bar/hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-定制主题"><a href="#2-定制主题" class="headerlink" title="2. 定制主题"></a>2. 定制主题</h3><p>这里推荐作者<code>洪卫</code>的<a href="https://github.com/shw2018/hexo-blog-fly.git">hexo-blog-fly</a>博客主题，该主题是基于<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>优化的，需要把博客相关信息换成您自己的就可以部署了，极大简化了构建博客的工作量和复杂度。</p><h4 id="2-1-简单使用方法"><a href="#2-1-简单使用方法" class="headerlink" title="2.1 简单使用方法"></a>2.1 简单使用方法</h4><ol><li>安装<code>Git</code>, 安装<code>nodeJS</code>，安装<code>Hexo</code></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地博客文件夹内</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>直接修改配置信息，改成自己的信息</li><li>运行命令<code>hexo clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><h4 id="2-2-原主题特性"><a href="#2-2-原主题特性" class="headerlink" title="2.2 原主题特性:"></a>2.2 原主题特性:</h4><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/">Gitalk</a>、<a href="https://imsun.github.io/gitment/">Gitment</a>、<a href="https://valine.js.org/">Valine</a> 和 <a href="https://disqus.com/">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li></ul><h4 id="2-3-新增加特性"><a href="#2-3-新增加特性" class="headerlink" title="2.3 新增加特性:"></a>2.3 新增加特性:</h4><ul><li>修改了原主题的一些很多bug</li><li>加入图片懒加载功能，在根目录配置文件开启和关闭</li><li>增加留言板功能</li><li>在关于板块,加入简历功能页</li><li>增加视听[视觉听觉影音]板块 </li><li>支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。</li><li>增加网站运行时间显示 </li><li>增加动漫模型 </li><li>整体替换Banner图片和文章特色图片</li><li>增加分类相册功能</li><li>修改了一些控件的参数</li><li>修改部分样式,比如: 文章卡片,固定高度,使其不至于因为文章摘要的长短不同导致卡片大小不一使页面布局很不美观,类似的还有友链卡片,优化了页面内容布局,视觉更整齐美观</li><li>解决首页文章列表卡片上方 border-radius圆角失效的bug</li><li>添加页面樱花飘落动效</li><li>添加鼠标点击烟花爆炸动效</li><li>加入天气接口控件</li><li>加入鼠标点击文字特效</li><li>添加页面雪花飘落动效</li><li>添加在线聊天插件</li><li>调整线聊天插件参数，使之能够随着鼠标滑动位置自适应调整</li><li>持续更新…</li></ul><hr><h4 id="2-4-切换主题"><a href="#2-4-切换主题" class="headerlink" title="2.4 切换主题"></a>2.4 切换主题</h4><p>如果想自己动手对<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>优化的话，可以修改Hexo根目录下的<code> _config.yml</code>的 <code>theme</code> 的值</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">theme: hexo-theme-matery<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>_config.yml</code> 文件的其它修改建议:</p><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h4 id="2-5-新建分类-categories-页"><a href="#2-5-新建分类-categories-页" class="headerlink" title="2.5 新建分类 categories 页"></a>2.5 新建分类 categories 页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "categories"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-6-新建标签-tags-页"><a href="#2-6-新建标签-tags-页" class="headerlink" title="2.6 新建标签 tags 页"></a>2.6 新建标签 tags 页</h4><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "tags"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-新建关于我-about-页"><a href="#2-7-新建关于我-about-页" class="headerlink" title="2.7 新建关于我 about 页"></a>2.7 新建关于我 about 页</h4><p><code>about</code> 页是用来展示关于我和我的博客信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "about"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-8-新建留言板-contact-页（可选的）"><a href="#2-8-新建留言板-contact-页（可选的）" class="headerlink" title="2.8 新建留言板 contact 页（可选的）"></a>2.8 新建留言板 contact 页（可选的）</h4><p><code>contact</code> 页是用来展示留言板信息的页面，前提是已经开启了第三方评论系统才能显示。如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "contact"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: contactdate: 2018-09-30 17:25:30type: "contact"layout: "contact"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-9-新建友情链接-friends-页（可选的）"><a href="#2-9-新建友情链接-friends-页（可选的）" class="headerlink" title="2.9 新建友情链接 friends 页（可选的）"></a>2.9 新建友情链接 friends 页（可选的）</h4><p><code>friends</code> 页是用来展示友情链接信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "friends"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[{    "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg",    "name": "码酱",    "introduction": "我不是大佬，只是在追寻大佬的脚步",    "url": "http://luokangyuan.com/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/4027734.jpeg",    "name": "闪烁之狐",    "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬",    "url": "https://blinkfox.github.io/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/avatar.jpg",    "name": "ja_rome",    "introduction": "平凡的脚步也可以走出伟大的行程",    "url": "https://me.csdn.net/jlh912008548",    "title": "前去学习"}]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-10-一级菜单导航配置"><a href="#2-10-一级菜单导航配置" class="headerlink" title="2.10 一级菜单导航配置"></a>2.10 一级菜单导航配置</h4><p>配置基本菜单导航的名称、路径<code>url</code>和图标<code>icon</code></p><ul><li>菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或主页) </li><li>图标<code>icon</code> 可以在<code>Font Awesome</code> 中查找</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle  Friends:    url: /friends    icon: fas fa-address-book<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-11-二级菜单配置方法"><a href="#2-11-二级菜单配置方法" class="headerlink" title="2.11 二级菜单配置方法"></a>2.11 二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作</p><ul><li>在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)</li><li>在<code>children</code>下创建二级菜单的 名称<code>name</code>,路径<code>url</code>和图标<code>icon</code>.</li><li>注意每个二级菜单模块前要加 -.</li><li>注意缩进格式</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle-o  Friends:    url: /friends    icon: fas fa-address-book  Medias:    icon: fas fa-list    children:      - name: Musics        url: /musics        icon: fas fa-music      - name: Movies        url: /movies        icon: fas fa-film      - name: Books        url: /books        icon: fas fa-book      - name: Galleries        url: /galleries        icon: fas fa-image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean</code> &amp;&amp; <code>hexo g</code> 重新生成博客文件。</p><h4 id="2-12-代码高亮"><a href="#2-12-代码高亮" class="headerlink" title="2.12 代码高亮"></a>2.12 代码高亮</h4><p>由于 <code>Hexo</code> 自带的代码高亮主题显示不好看，所以主题中使用到了 <code>hexo-prism-plugin</code> 的 <code>Hexo</code> 插件来做代码高亮，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，修改 <code>Hexo</code> 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">highlight:  enable: falseprism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>更多代码块优化详细内容请访问：<a href="http://luckyzmj.cn/posts/1b9a9e28.html">http://luckyzmj.cn/posts/1b9a9e28.html</a></p></blockquote><h4 id="2-13-搜索"><a href="#2-13-搜索" class="headerlink" title="2.13 搜索"></a>2.13 搜索</h4><p>本主题中还使用到了 <code>hexo-generator-search</code> 的 <code>Hexo</code> 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>Hexo</code> 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-14-文章字数统计插件（建议安装）"><a href="#2-14-文章字数统计插件（建议安装）" class="headerlink" title="2.14 文章字数统计插件（建议安装）"></a>2.14 文章字数统计插件（建议安装）</h4><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <code>hexo-wordcount</code> 插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">postInfo:  date: true  update: false  wordCount: false # 设置文章字数统计为 true.  totalCount: false # 设置站点文章总字数统计为 true.  min2read: false # 阅读时长.  readCount: false # 阅读次数.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-15-添加emoji表情支持（可选的）"><a href="#2-15-添加emoji表情支持（可选的）" class="headerlink" title="2.15 添加emoji表情支持（可选的）"></a>2.15 添加emoji表情支持（可选的）</h4><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <code>hexo-filter-github-emojis</code> 的 <code>Hexo</code> 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown</code> <code>emoji</code>语法（::,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-filter-github-emojis --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>Hexo</code> 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">githubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-16-添加-RSS-订阅支持（可选的）"><a href="#2-16-添加-RSS-订阅支持（可选的）" class="headerlink" title="2.16 添加 RSS 订阅支持（可选的）"></a>2.16 添加 RSS 订阅支持（可选的）</h4><p>本主题中还使用到了<code>hexo-generator-feed</code>  的 <code>Hexo</code> 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-generator-feed --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>Hexo</code> 根目录下的<code> _config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean</code> &amp;&amp; <code>hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h4 id="2-17-添加-DaoVoice-在线聊天功能（可选的）"><a href="#2-17-添加-DaoVoice-在线聊天功能（可选的）" class="headerlink" title="2.17 添加 DaoVoice 在线聊天功能（可选的）"></a>2.17 添加 DaoVoice 在线聊天功能（可选的）</h4><p>前往 <code>DaoVoice</code> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h4 id="2-18-添加-Tidio-在线聊天功能（可选的）"><a href="#2-18-添加-Tidio-在线聊天功能（可选的）" class="headerlink" title="2.18 添加 Tidio 在线聊天功能（可选的）"></a>2.18 添加 Tidio 在线聊天功能（可选的）</h4><p>前往 <code>Tidio</code> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h4 id="2-19-修改页脚"><a href="#2-19-修改页脚" class="headerlink" title="2.19 修改页脚"></a>2.19 修改页脚</h4><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h4 id="2-20-修改社交链接"><a href="#2-20-修改社交链接" class="headerlink" title="2.20 修改社交链接"></a>2.20 修改社交链接</h4><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;% if (theme.socialLink.github) { %&gt;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;%= theme.socialLink.github %&gt;<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fab fa-github<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>&lt;% } %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <code>Font Awesome</code> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: fab fa-facebook</li><li>Twitter: fab fa-twitter</li><li>Google-plus: fab fa-google-plus</li><li>Linkedin: fab fa-linkedin</li><li>Tumblr: fab fa-tumblr</li><li>Medium: fab fa-medium</li><li>Slack: fab fa-slack</li><li>Sina Weibo: fab fa-weibo</li><li>Wechat: fab fa-weixin</li><li>QQ: fab fa-qq</li><li>Zhihu: fab fa-zhihu</li></ul><p>注意: 本主题中使用的 <code>Font Awesome</code> 版本为 5.11.0。</p><h4 id="2-21-修改打赏的二维码图片"><a href="#2-21-修改打赏的二维码图片" class="headerlink" title="2.21 修改打赏的二维码图片"></a>2.21 修改打赏的二维码图片</h4><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h4 id="2-22-配置音乐播放器（可选的）"><a href="#2-22-配置音乐播放器（可选的）" class="headerlink" title="2.22 配置音乐播放器（可选的）"></a>2.22 配置音乐播放器（可选的）</h4><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活<code>music</code>配置即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 是否在首页显示音乐music:  enable: true  title:         #非吸底模式有效    enable: true    show: 听听音乐  server: netease   #require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    #require song, playlist, album, search, artist  id: 503838841     #require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: false   # 是否自动播放  theme: '#42b983'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠提示：    server可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐）。    type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手）    id获取示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，地址栏有一串数字，playlist的id即为这串数字。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-23文章-Front-matter-介绍"><a href="#2-23文章-Front-matter-介绍" class="headerlink" title="2.23文章 Front-matter 介绍"></a>2.23文章 Front-matter 介绍</h4><p><code>Front-matter</code> 选项中的所有内容均为非必填的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>Markdown 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 _config.yml 中的 author</td><td>文章作者</td></tr><tr><td>img</td><td>featureImages 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <a href="http://xxx.com/xxx.jpg">http://xxx.com/xxx.jpg</a></td></tr><tr><td>top</td><td>true</td><td>推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章</td></tr><tr><td>cover</td><td>false</td><td>v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td>v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项</td></tr><tr><td>toc</td><td>true</td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项</td></tr><tr><td>mathjax</td><td>false</td><td>是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">注意:    如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。    date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。    如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。    您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下为文章的 <code>Front-matter</code> 示例。<br>最简示例</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最全示例</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-24-自定制修改"><a href="#2-24-自定制修改" class="headerlink" title="2.24 自定制修改"></a>2.24 自定制修改</h4><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li>favicon 和 Logo</li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li>Gitalk、Gitment、Valine 和 disqus 评论配置</li><li>不蒜子统计和谷歌分析（Google Analytics）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图</li></ul><p>我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：<br>修改主题颜色</p><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector">.bg-color</span> <span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right<span class="token punctuation">,</span> #4cbf30 0%<span class="token punctuation">,</span> #0f9d58 100%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">{</span>   <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">{</span>    <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span class="token selector">body</span> <span class="token punctuation">{</span>    <span class="token comment">/* background-color: #eaeaea; */</span>    <span class="token comment">/* 增加背景壁纸*/</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">"https://ae01.alicdn.com/kf/H18a4b998752a4ae68b8e85d432a5aef0l.png"</span><span class="token punctuation">)</span></span><span class="token punctuation">,</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">"http://luckyzmj.cn/img/yun.jpg"</span><span class="token punctuation">)</span></span> 0px 0px<span class="token punctuation">;</span>    <span class="token property">background-attachment</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> #34495e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-25-修改-banner-图和文章特色图"><a href="#2-25-修改-banner-图和文章特色图" class="headerlink" title="2.25 修改 banner 图和文章特色图"></a>2.25 修改 banner 图和文章特色图</h4><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">$<span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span>.<span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> + new <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> + <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h4 id="2-26-优化目录栏"><a href="#2-26-优化目录栏" class="headerlink" title="2.26 优化目录栏"></a>2.26 优化目录栏</h4><p>在 <code>themes\Matery\layout\_partial\post-detail-toc.ejs</code>，修改内容如下：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.toc-widget</span> <span class="token punctuation">{</span>    <span class="token property">padding-left</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 345px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgb</span><span class="token punctuation">(</span>255<span class="token punctuation">,</span> 255<span class="token punctuation">,</span> 255<span class="token punctuation">,</span>0.7<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> 0 10px 35px 2px <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> .15<span class="token punctuation">)</span><span class="token punctuation">,</span> 0 5px 15px <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> .07<span class="token punctuation">)</span><span class="token punctuation">,</span> 0 2px 5px -5px <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> .1<span class="token punctuation">)</span> <span class="token important">!important</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#toc-content</span> <span class="token punctuation">{</span>    <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x005-更多详细教程"><a href="#0x005-更多详细教程" class="headerlink" title="0x005 更多详细教程"></a>0x005 更多详细教程</h2><p>以下几篇文章都是基于<code>Hexo</code>框架和<code>hexo-theme-matery</code>主题优化的教程，大家如果遇到问题，可以参考其中的方法。</p><ul><li><a href="https://sunhwee.com/posts/6e8839eb.html">Hexo+Github博客搭建完全教程</a></li><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery作者教程</a></li><li><a href="https://yafine-blog.cn/posts/4ab2.html">Hexo+github搭建博客(超级详细版，精细入微)</a></li><li><a href="https://blog.csdn.net/cungudafa/article/details/106278206">hexo（matery）背景、滚动条优化+增加点击跳评论</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="博客篇" scheme="http://quricolouis.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"/>
    
    
    <category term="Hexo" scheme="http://quricolouis.github.io/tags/Hexo/"/>
    
    <category term="Github" scheme="http://quricolouis.github.io/tags/Github/"/>
    
    <category term="博客" scheme="http://quricolouis.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Java并发实现原理「JDK源码剖析」</title>
    <link href="http://quricolouis.github.io/posts/cd039684.html"/>
    <id>http://quricolouis.github.io/posts/cd039684.html</id>
    <published>2019-08-27T03:41:03.000Z</published>
    <updated>2021-08-11T16:39:26.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-多线程基础"><a href="#第一章-多线程基础" class="headerlink" title="第一章  多线程基础"></a>第一章  多线程基础</h1><h2 id="1-1-线程关闭"><a href="#1-1-线程关闭" class="headerlink" title="1.1  线程关闭"></a>1.1  线程关闭</h2><h3 id="1-1-1-stop-与-destory-函数"><a href="#1-1-1-stop-与-destory-函数" class="headerlink" title="1.1.1  stop() 与 destory() 函数"></a>1.1.1  stop() 与 destory() 函数</h3><p>问：运行一半的线程能否强制杀死？<br>答：在Java中，stop()、destory()之类的函数官方明确不建议使用，如果强制杀死线程，则线程中所用的资源，例&nbsp; 如文件描述符、网络连接等不能正常关闭。<br>一个线程一旦运行起，就不要去强行打断它，合理的关闭方法是让其运行完（也就是函数执行完毕），干净地&nbsp; 释放掉所有的资源，然后推出。如果是一个不断循环运行的线程，就需要用到线程间的通信机制，让主线程通知其退出。</p><h3 id="1-1-2-守护线程"><a href="#1-1-2-守护线程" class="headerlink" title="1.1.2 守护线程"></a>1.1.2 守护线程</h3><p>当在一个JVM进程里开多个线程时，这些线程被分成两类：<strong>守护线程</strong>和<strong>非守护线程</strong>。默认开的是<strong>非守护线程</strong>。<br>当所有的非守护线程推出后，整个JVM进程就会退出。意思就是守护线程“不算数”，守护线程不影响整个JVM进程的退出。例如：<strong>垃圾回收线程就是守护线程</strong>，它们在后台默默工作，当开发者的所有前台线程(非守护线程)都退出之后，整个JVM进程就退出了。</p><h2 id="1-2-interruptedException-函数与-interrupt-函数"><a href="#1-2-interruptedException-函数与-interrupt-函数" class="headerlink" title="1.2  interruptedException() 函数与 interrupt() 函数"></a>1.2  interruptedException() 函数与 interrupt() 函数</h2><h3 id="1-2-1-什么情况下会抛出-interrupted-异常"><a href="#1-2-1-什么情况下会抛出-interrupted-异常" class="headerlink" title="1.2.1  什么情况下会抛出 interrupted 异常"></a>1.2.1  什么情况下会抛出 interrupted 异常</h3><p>只有声明了会抛出 InterruptedException 的函数才会抛出异常<br>例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public static native void sleep(long millis) throws InterruptedException{...}public final void wait() throws InterruptedException{...}public final void join() throws InterruptedException{...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-2-2-轻量级阻塞与重量级阻塞"><a href="#1-2-2-轻量级阻塞与重量级阻塞" class="headerlink" title="1.2.2  轻量级阻塞与重量级阻塞"></a>1.2.2  轻量级阻塞与重量级阻塞</h3><p><strong>轻量级阻塞：</strong>能够被中断的阻塞。对应的线程状态是 WAITING 或者 TIMED_WAITING。<br><strong>重量级阻塞：</strong>像 synchronized 这种不能被中断的阻塞。对应的状态 BLOCKED。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627270281876-93f83d61-a06c-46f0-9932-1342a86b977c.png#align=left&amp;display=inline&amp;height=183&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=366&amp;originWidth=715&amp;size=121601&amp;status=done&amp;style=none&amp;width=357.5" alt="image.png"><br>图1-1  线程的状态迁移过程</p><h3 id="1-2-3-t-isInterrupted-与-Thread-interrupted"><a href="#1-2-3-t-isInterrupted-与-Thread-interrupted" class="headerlink" title="1.2.3  t.isInterrupted() 与 Thread.interrupted()"></a>1.2.3  t.isInterrupted() 与 Thread.interrupted()</h3><p>t.interrupted() 相当于给线程发送了一个唤醒的信号,果线程此时恰好处于 waiting 或者  timed_waiting 状态，        就会抛出一个InterruptedException，并且线程被唤醒。而如果线程此时并没有被阻塞，则线程什么都不会做。但在后续，线程可以判断自己是否收到过其他线程发来的中断信号，然后做一些对应的处理。<br><strong>前者是静态函数，后者是非静态函数，两者之间的区别在于前者只是读取中断状态，不做修改状态；后者不仅读取中断状态，还会重置中断标志位。</strong>    </p><h2 id="1-3-synchronized-关键字"><a href="#1-3-synchronized-关键字" class="headerlink" title="1.3  synchronized 关键字"></a>1.3  synchronized 关键字</h2><h3 id="1-3-1-锁的对象是什么"><a href="#1-3-1-锁的对象是什么" class="headerlink" title="1.3.1  锁的对象是什么"></a>1.3.1  锁的对象是什么</h3><p>synchronized关键字的意思是给某个对象加了把锁</p><ul><li>对于非静态成员函数，锁其实是家在 a 对象上面的；</li><li>对于静态成员函数，锁是加在 A.class 上面的</li></ul><p><strong>一个静态成员函数和一个非静态成员函数，都加了synchronized关键字，分别被两个线程调用，它们是否互斥？</strong><br><strong>答：因为是两把不同的锁，所以不会互斥</strong></p><h3 id="1-3-2-锁的本质是什么"><a href="#1-3-2-锁的本质是什么" class="headerlink" title="1.3.2  锁的本质是什么"></a>1.3.2  锁的本质是什么</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627296855136-6b6218ef-254e-4981-bcab-5ce178231f2b.png#align=left&amp;display=inline&amp;height=113&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=225&amp;originWidth=753&amp;size=42435&amp;status=done&amp;style=none&amp;width=376.5" alt="image.png"><br>图 1-2 线程、锁和资源关系图<br>多个线程要访问同一个资源。线程就是一段段运行的代码；资源就是一个变量、一个对象或一个文件等；而锁就是要实现线程对资源的访问控制，保证同一时间只能有一个线程去访问某一个资源。<br><strong>从程序角度，锁就是一个“对象”，这个对象要完成的事情：</strong></p><ol><li>这个对象内部得有一个标志位（state变量），记录自己有没有被某个线程占用。最简单的情况是这个 <strong>state</strong> 有 0、1 两个取值，0 表示没有线程占用这个锁，1 表示有某个线程占用了这个锁</li><li>如果这个对象被某个线程占用，它得记录这个线程的 thread ID，知道自己是被哪个线程占用了。</li><li>这个对象还得维护一个 thread id list，记录其他所有阻塞的、等待拿这个锁的线程。在当前线程释放锁之后（也就是把state从1改回0），从这个 thread id list 里面取一个线程唤醒。</li></ol><p><strong>既然锁是一个对象，要访问的共享资源本身也是一个对象，这两个对象可以合成一个对象。</strong><br>资源和锁合二为一，使得在 Java 里面，synchronized 关键字可以加在任何对象的成员上面。这也就意味着，这个对象既是共享资源，同时也具备“锁”的功能。</p><h3 id="1-3-3-synchronized-实现原理"><a href="#1-3-3-synchronized-实现原理" class="headerlink" title="1.3.3  synchronized 实现原理"></a>1.3.3  synchronized 实现原理</h3><p>在 Java 的对象头里，有一块数据叫 Mark Word。在64位机器上，Mark Word 是8字节（64位）的，这64位中有2个重要字段：<strong>锁标志位</strong>和**占用锁的 tread ID。 **</p><h2 id="1-4-wait-与-notify"><a href="#1-4-wait-与-notify" class="headerlink" title="1.4  wait() 与 notify()"></a>1.4  wait() 与 notify()</h2><h3 id="1-4-1-生产者-消费者模型"><a href="#1-4-1-生产者-消费者模型" class="headerlink" title="1.4.1  生产者-消费者模型"></a>1.4.1  生产者-消费者模型</h3><p><strong>生产者-消费者模型是一个常见的多线程编程模型。</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627296966953-a10ed925-c2cb-461a-a66b-4d4207db1efa.png#align=left&amp;display=inline&amp;height=149&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=298&amp;originWidth=728&amp;size=71188&amp;status=done&amp;style=none&amp;width=364" alt="image.png"></strong><br>图 1-4 生产者-消费者模型<br>一个内存队列，多个生产者线程我那个内存队列放数据；多个消费者线程从内存队列中取数据要实现这样一个编程模型，<strong>需要做下面几件事情：</strong></p><ol><li>内存队列本身要加锁，才能实现线程安全。</li><li>阻塞。当内存队列满了，生产者放不进去时，会被阻塞；当内存队列是空的时候，消费者无事可做，会被阻塞。</li><li>双向管理。消费者被阻塞之后，生产者放入新数据，要 notify() 消费者；反之，生产者被阻塞之后，消费者消费了数据，要 notify() 生产者。</li></ol><p><strong>第 1 件事必须要做，第 2 件事和第 3 件事不一定要做。</strong></p><ul><li><strong>如何阻塞？</strong></li></ul><p>办法1：线程自己阻塞自己，也就是生产者、消费者线程各自调用 wait() 和 notify()。<br>办法2：用一个阻塞队列，当取不到或者放不进去数据的时候，入队/出队函数本身就是阻塞的。</p><ul><li><strong>如何双向通知？</strong></li></ul><p>办法1：wait() 和 notify() 机制。<br>办法2：Condition机制</p><h3 id="1-4-2-为什么必须和-synchronized-一起使用"><a href="#1-4-2-为什么必须和-synchronized-一起使用" class="headerlink" title="1.4.2  为什么必须和 synchronized 一起使用"></a>1.4.2  为什么必须和 synchronized 一起使用</h3><p>开两个线程，线程A调用f1()，线程B调用f2()。两个线程之间要<strong>通信</strong>，对于同一个对象来说，一个线程调用该对象的 wait()，另一个线程调用该对象的 notify()，该对象本身就需要同步！所以，在调用 wait()、notify() 之前，要先通过 synchronized 关键字同步给对象，也就是给该对象加锁。</p><h3 id="1-4-3-为什么-wait-的时候必须释放锁"><a href="#1-4-3-为什么-wait-的时候必须释放锁" class="headerlink" title="1.4.3  为什么 wait() 的时候必须释放锁"></a>1.4.3  为什么 wait() 的时候必须释放锁</h3><p>wait()内部伪代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wait(){//释放锁//阻塞，等待被其他线程notify//重新拿锁}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-4-wait-与-notify-的问题"><a href="#1-4-4-wait-与-notify-的问题" class="headerlink" title="1.4.4  wait() 与 notify() 的问题"></a>1.4.4  wait() 与 notify() 的问题</h3><p>生产者本来只想通知消费者，但它把其他的生产者也通知了；消费者本来只想通知生产者，但它把其他的消费者也通知了。原因是 wait() 和 notify() 作用的对象和 synchronized 作用的对象是同一个，每个对象没有区分标识。<strong>精确唤醒我们可以用 Condition 来实现。</strong></p><h2 id="1-5-volatile-关键字"><a href="#1-5-volatile-关键字" class="headerlink" title="1.5  volatile 关键字"></a>1.5  volatile 关键字</h2><h3 id="volatile三重功效"><a href="#volatile三重功效" class="headerlink" title="volatile三重功效"></a>volatile三重功效</h3><ul><li>64位写入的原子性</li><li>内存可见性</li><li>禁止重排序<h3 id="1-5-1-64位写入的原子性（Half-Write）"><a href="#1-5-1-64位写入的原子性（Half-Write）" class="headerlink" title="1.5.1  64位写入的原子性（Half Write）"></a>1.5.1  64位写入的原子性（Half Write）</h3>多线程场景下，线程 A 调用 set(100)，线程 B 调用 get()，在某些场景下，返回值可能不是 100 。<br>这是因为 JVM 规范没有要求 64 位的 long 或者 double 的写入是原子的。在 32 位的机器上，一个 64 位变量的写入可能被拆分成两个 32 位的写操作来执行。这样一来，读取线程就可能读到<strong>一半的值</strong> 。<br>解决办法也：在 long 前面加上 <strong>volatile</strong> 关键字。<h3 id="1-5-2-内存可见性"><a href="#1-5-2-内存可见性" class="headerlink" title="1.5.2  内存可见性"></a>1.5.2  内存可见性</h3>不仅 64 位，32 位或者位数更小的赋值和取值操作，其实也有问题。比如一个线程修改变量值为 true 之后，另一个线程去读，读到的事 false，但是之后能读到 true。也就是<strong>最终一致性</strong>，不是<strong>强一致性</strong>。<br>所以，<strong>内存可见性</strong>， 指的是<strong>写完之后立即对其他线程可见</strong>，它的反面不是<strong>不可见</strong>，而是<strong>稍后才能看见</strong>。<br>解决这个问题很容易，给变量加上 <strong>volatile</strong> 关键字即可。<h3 id="1-5-3-重排序：DCL问题"><a href="#1-5-3-重排序：DCL问题" class="headerlink" title="1.5.3  重排序：DCL问题"></a>1.5.3  重排序：DCL问题</h3>单例模式的线程安全，常用写法为DCL（Double Checking Locking）<pre class="line-numbers language-java" data-language="java"><code class="language-java">public case Sington {   private static Sington instance;  private static Sington getInstance() {      if (instance == null) {// DCL          synchronized(Sington.class) {// 为了性能，延迟使用synchronized              if (instance == null)                  instance = new Instance();// 有问题的代码            }        }    }  return instance;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>上述的 instance = new Instance() 代码有问题：其底册会分为三个操作：</li></ul><ol><li>分配一块内存</li><li>在内存上初始化成员变量</li><li>把 instance 引用指向内存。</li></ol><p><strong>操作2和3可能重排序。</strong>即先把 instance 指向内存，再初始化成员变量，因为二者先后<strong>没有依赖关系</strong>。此时，另一个线程可能拿到一个未完全初始化的对象，直接去访问里面的成员变量，就可能出错。这就是典型的“<strong>构造函数溢出</strong>”问题。<br>解决方法：为 instance 变量加上 <strong>volatile</strong> 修饰。</p><h2 id="1-6-JVM与happen-before"><a href="#1-6-JVM与happen-before" class="headerlink" title="1.6  JVM与happen-before"></a>1.6  JVM与happen-before</h2><h3 id="1-6-1-为什么会存在“内存可见性”问题"><a href="#1-6-1-为什么会存在“内存可见性”问题" class="headerlink" title="1.6.1  为什么会存在“内存可见性”问题"></a>1.6.1  为什么会存在“内存可见性”问题</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627375870977-edfcb6bd-061c-4720-bdd8-66a36e55e0a9.png#align=left&amp;display=inline&amp;height=324&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=648&amp;originWidth=1018&amp;size=338606&amp;status=done&amp;style=none&amp;width=509" alt="image.png"><br>图 1-4  加入 Store Buffer 和 Load Buffer 的 CPU 缓存体系<br>L1、L2、L3 和主内存之间是同步的，有缓存一致性协议的保证，但是 Store Buffer、Load Buffer 和 L1之间却是异步的。也就是说，往内存中写入一个变量，这个变量会保存在 Storre Buffer 里面，稍后才会异步地写入 L1 中，同时同步 写入主内存中。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627376276849-d991e1f0-a1d8-4659-9545-e2665dd99ba2.png#align=left&amp;display=inline&amp;height=267&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=534&amp;originWidth=1086&amp;size=270710&amp;status=done&amp;style=none&amp;width=543" alt="image.png"><br>图 1-5  操作系统内核视角下的CPU缓存模型<br>多个 CPU，多个 CPU 多核，每个核上面可能还有多个硬件线程，对于操作系统来讲，就相当于一个个逻辑 CPU。每个逻辑CPU都有自己的缓存，这些缓存和主内存之间不是完全同步的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627376529987-06147cc8-e507-4b54-846a-98478d7e5a37.png#align=left&amp;display=inline&amp;height=268&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=536&amp;originWidth=1086&amp;size=231202&amp;status=done&amp;style=none&amp;width=543" alt="image.png"><br>图 1-6  JVM抽象内存模型<br>对应到 Java 里，就是 JVM 抽象内存模型</p><h3 id="1-6-2-重排序与内存可见性的问题"><a href="#1-6-2-重排序与内存可见性的问题" class="headerlink" title="1.6.2  重排序与内存可见性的问题"></a>1.6.2  重排序与内存可见性的问题</h3><p>重排序分类：</p><ul><li>编译器重排序：对于没有先后依赖关系的语句，编译器可以重新调整语句的执行顺序</li><li>CPU 指令重排序：在指令级别，让没有依赖关系的多条指令并行</li><li>CPU 内存重排序：CPU 有自己的缓存，指令的执行顺序和写入主内存的顺序不完全一致</li></ul><p><strong>CPU 内存重排序是造成“内存可见性”问题的主因</strong><br>例：假设有两个线程，线程 1 执行 X = 1 命令 和 a = Y 命令，线程 2 执行 Y = 1 命令 和 b = X 命令。最后 a、b 的结果应该是什么？<br>因为 线程 1 和 线程 2 的执行顺序不确定，所以结果可能是</p><ul><li>a = 0, b = 1</li><li>a = 1, b = 0</li><li>a = 1, b = 1</li></ul><p>正常就这三种可能性，但实际还可能是 a = 0, b = 0，为什么呢？<br>原因是线程 1先执行 X = 1 后执行 a = Y，但此时 X = 1 还在自己的 Store Buffer 里，但在线程2看来，a = Y 和 X = 1 顺序却是颠倒的。指令没有重排序，写入内存的操作被延迟了，也就是内存被重排序了，这就造成内存可见行问题。</p><h3 id="1-6-3-as-if-serial-语义"><a href="#1-6-3-as-if-serial-语义" class="headerlink" title="1.6.3&nbsp; as-if-serial 语义"></a>1.6.3&nbsp; as-if-serial 语义</h3><p>对于开发者而言，希望不要有任何的重排序，指令执行顺序和代码顺序严格一致，写内存的顺序也严格和代码顺序一致。<br>对于编译器和CPU，希望尽最大可能进行重排序，提升运行效率。<br><strong>单线程程序的重排序规则</strong>：只要操作之间没有依赖性，编译器和 CPU 就可以任意重排序，因为执行结果不会改变。这也就是 as-if-serial 语义。<br><strong>多线程程序的重排序规则</strong>：编译器和 CPU 只能保证每个线程的 as-if-serial 语义。线程之间的数据依赖和线程影响，需要编译器和 CPU 的上层来决定。</p><h3 id="1-6-4-happen-before-是什么"><a href="#1-6-4-happen-before-是什么" class="headerlink" title="1.6.4  happen-before 是什么"></a>1.6.4  happen-before 是什么</h3><p>如果 A happen-before B，意味着 A 的执行结果必须对 B 可见，也就是保证跨线程的内存可见性。<strong>A happen-before B 不代表A一定在B之前执行。</strong><br>基于 happen-before 这种描述方法，JMM 对开发者做出了一系列承诺：</p><ul><li>单线程中的每个操作，happen-before 对应线程中任意后续操作</li><li>对 volatile 变量的写入，happen-before 对应后续对这个变量的读取</li><li>对 synchronized 的解锁，happen-before 对应后续对这个锁的加锁</li></ul><p>对于非 volatile 变量的写入和读取，不在这个承诺之列。通俗来讲，就是JVM对编译器和CPU来说，volatilt 变量不能重排序；非 volatilt 变量可以任意重排序。</p><h3 id="1-6-5-happen-before-的传递性"><a href="#1-6-5-happen-before-的传递性" class="headerlink" title="1.6.5  happen-before 的传递性"></a>1.6.5  happen-before 的传递性</h3><p>volatile、synchronized 都具有 happen-before 语义。</p><h3 id="1-6-6-C-中的-volatile-关键字"><a href="#1-6-6-C-中的-volatile-关键字" class="headerlink" title="1.6.6  C++中的 volatile 关键字"></a>1.6.6  C++中的 volatile 关键字</h3><p>在 Java 中的 volatile 关键字不仅具有内存可见性，还会禁止 volatile 变量写入和非 volatile 变量写入的重排序；C++ 中的 volatile 关键字不会禁止这种重排序。</p><h3 id="1-7-内存屏障"><a href="#1-7-内存屏障" class="headerlink" title="1.7  内存屏障"></a>1.7  内存屏障</h3><p>为了禁止编译器重排序和CPU重排序，在编译器和CPU层面都有对应的指令。<br>编译器的内存屏障，知只是为了告诉编译器不要对指令进行重排序。当变异完成之后，这种内存屏障就消失了。<br>CPU内存屏障是CPU提供的指令，可以由开发者显示调用。</p><h3 id="1-7-1-Linux-中的内存屏障"><a href="#1-7-1-Linux-中的内存屏障" class="headerlink" title="1.7.1  Linux 中的内存屏障"></a>1.7.1  Linux 中的内存屏障</h3><p>通过函数 smp_wmb() 插入了一个 Store Barrier 屏障，从而确保了：</p><ul><li>更新指针的操作，不会被重排序到修改数据之前。</li><li>更新指针的时候，Store Cache 被刷新，其他CPU可见<h3 id="1-7-2-JDK-中的内存屏障"><a href="#1-7-2-JDK-中的内存屏障" class="headerlink" title="1.7.2  JDK 中的内存屏障"></a>1.7.2  JDK 中的内存屏障</h3>JDK8开始，Java在 Unsafe 类中提供了三个内存屏障函数(不是最基本的内存屏障)：<pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class Unsafe{public native void loadFence();//loadFence=LoadLoad+LoadStore    public native void storeFence();//storeFence=StoreFence+LoadStore    public native void fullFence();//fullFence=LoadFence+StoreFence+StoreLoad}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>在理论层面，可以把基本的CPU内存屏障分为4种：</li></ul><ol><li><p>LoadLoad：禁止读和读的重排序</p></li><li><p>StoreStore：禁止写和写的重排序</p></li><li><p>LoadStore：禁止读和写的重排序</p></li><li><p>StoreLoad：禁止写和读的重排序</p><h3 id="1-7-3-volatile-实现原理"><a href="#1-7-3-volatile-实现原理" class="headerlink" title="1.7.3  volatile 实现原理"></a>1.7.3  volatile 实现原理</h3><p>实现 volatile 关键字的语义参考做法：</p></li><li><p>在 volatile 写操作的前面插入一个 StoreStore 屏障。保证 volatile 写操作不会和之前的写操作重排序。</p></li><li><p>在 volatile 写操作的后面插入一个 StoreLoad 屏障。保证 volatile 写操作不会和之后的读操作重排序。</p></li><li><p>在 volatile 读操作的后面插入一个 LoadLoad 屏障 + LoadStore 屏障。保证 volatile 读操作不会和之后的读操作、写操作重排序。</p><h2 id="1-8-final-关键字"><a href="#1-8-final-关键字" class="headerlink" title="1.8  final 关键字"></a>1.8  final 关键字</h2><h3 id="1-8-1-构造函数溢出问题"><a href="#1-8-1-构造函数溢出问题" class="headerlink" title="1.8.1  构造函数溢出问题"></a>1.8.1  构造函数溢出问题</h3><p>对于构造函数溢出，就是一个对象的构造<strong>并不是“原子的”</strong>，当一个线程正在构造对象时，另外一个线程却可以读到未构造好的“一半对象”。</p><h3 id="1-8-2-final-的-happen-before-语义"><a href="#1-8-2-final-的-happen-before-语义" class="headerlink" title="1.8.2  final 的 happen-before 语义"></a>1.8.2  final 的 happen-before 语义</h3><p>解决构造函数溢出的办法：</p></li><li><p>给变量都加上 volitile 关键字</p></li><li><p>为 read/write 函数都加上 synchronized 关键字</p></li><li><p>给变量加上 final 关键字</p></li></ol><p>final 的 happen-before 语义：</p><ol><li>对 final 域的写（构造函数内部），happen-before 于后续对 final 域所在对象的读</li><li>对 final 域所在对象的读，happen-before 于后续对 final 域的读</li></ol><p>通过这种 happen-before 语义的限定，保证了 final 域的赋值，一定在构造函数之前完成，不会出现另外一个线程读取到了对象，但对象里面的变量却还没有初始化的情形，避免出现构造函数溢出的问题。</p><h3 id="1-8-3-happen-before-规则总结"><a href="#1-8-3-happen-before-规则总结" class="headerlink" title="1.8.3  happen-before 规则总结"></a>1.8.3  happen-before 规则总结</h3><ol><li>单线程中的每个操作，happen-before 于该线程中任意后续操作</li><li>对 volatile 变量的写，happen-before 于后续对这个变量的读</li><li>对 synchronized 的解锁，happen-before 于后续对这个锁的加锁</li><li>对 final 变量的写，happen-before 于 final 域对象的读，happen-before 于后续对 final 变量的读</li></ol><p>四个基本规则再加上 hapen-before 的传递性，就构成JVM对开发者的整个承诺<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627392881708-75d6007a-d8cb-455b-acc0-a2b9b64893d2.png#align=left&amp;display=inline&amp;height=375&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=750&amp;originWidth=902&amp;size=256649&amp;status=done&amp;style=none&amp;width=451" alt="image.png"><br>图 1-7  从底向上看 volatile 背后的原理</p><h1 id="第二章-Atomic类"><a href="#第二章-Atomic类" class="headerlink" title="第二章 Atomic类"></a>第二章 Atomic类</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627468800067-00b5a7f8-412f-48a4-bb32-0b8bd45b2dbc.png#align=left&amp;display=inline&amp;height=293&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=586&amp;originWidth=540&amp;size=149574&amp;status=done&amp;style=none&amp;width=270" alt="image.png"><br>图 2-1  整个 Concurrent 包的层次体系</p><h2 id="2-1-AtomicInteger-和-AtomicLong"><a href="#2-1-AtomicInteger-和-AtomicLong" class="headerlink" title="2.1 AtomicInteger 和 AtomicLong"></a>2.1 AtomicInteger 和 AtomicLong</h2><h3 id="2-1-1-悲观锁与乐观锁"><a href="#2-1-1-悲观锁与乐观锁" class="headerlink" title="2.1.1 悲观锁与乐观锁"></a>2.1.1 悲观锁与乐观锁</h3><p>悲观锁：数据发生并发冲突的概率很大，所以读操作之前就上锁。synchronized 关键字和 ReentrantLock 都是悲观锁的典型例子。<br>乐观锁：数据发生并发冲突的概率很小，所以读操作之前不上锁。等到写操作的时候，再判断数据在此期间是否被其他线程修改了。如果被其他线程修改了，就把数据重新读出来，重复该过程；如果没有被修改，就写回去。判断数据是否被修改，同时写回新值，这两个操作要合成一个原子操作，也就是CAS（Compare And Set）。AtomicInteger就是典型的乐观锁</p><h3 id="2-1-2-Unsafe的CAS详解"><a href="#2-1-2-Unsafe的CAS详解" class="headerlink" title="2.1.2 Unsafe的CAS详解"></a>2.1.2 Unsafe的CAS详解</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final boolean compareAndSet(int expect, int update){    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>AtomicInteger 封装过的 compareAndSet 有两个参数。第一个参数 expect 是指变量的旧值（是读出来的值，写回去的时候，希望没有被其他线程修改）；第二个参数 update 是指变量的新值（修改过的，没有写入的值）。当 expect 变量等于当前变量时，说明在修改的期间，没有其他线程对此变量进行过修改，所以可以成功写入，变量被更新为 update，返回 true；否则返回 false；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数有4个参数，第一个是对象（AtomicInteger 变量）；第二个是对象的成员变量（AtomicInteger 里面包的 int 变量 value），它是 long 型整数，常被称为 xxxOffset，意思是某个成员变量在对应的类中的内存偏移量，表示该成员变量本身。<br>无论是 Unsafe 还是 valueOffset，都是静态的，也就是类级别的，所有对象共用的。<br>在转化的时候，先通过反射（getDeclaredField）获取 value 成员变量对应的 Field 对象，再通过 objectFieldOffset 函数转化成 valueOffset。此处的 valueOffset 就代表了 value 变量本身，后面执行CAS操作的时候，不是直接操作 value，而是操作 valueOffset。</p><h3 id="2-1-3-自旋与阻塞"><a href="#2-1-3-自旋与阻塞" class="headerlink" title="2.1.3 自旋与阻塞"></a>2.1.3 自旋与阻塞</h3><p>当一个线程拿不到锁的时候，有两种基本的等待策略：<br>策略1：放弃CPU，进入阻塞状态，等待后续被唤醒，再重新被操作系统调度。<br>策略2：不放弃CPU，空转，不断重试，也就是所谓的“自旋”。<br>这两种策略不是互斥的，可以结合使用。</p><h2 id="2-2-AtomicBoolean-和-AtomicReference"><a href="#2-2-AtomicBoolean-和-AtomicReference" class="headerlink" title="2.2 AtomicBoolean 和 AtomicReference"></a>2.2 AtomicBoolean 和 AtomicReference</h2><h3 id="2-2-1-为什么需要-AtomicBoolean"><a href="#2-2-1-为什么需要-AtomicBoolean" class="headerlink" title="2.2.1 为什么需要 AtomicBoolean"></a>2.2.1 为什么需要 AtomicBoolean</h3><p>AtomicBoolean：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(flag == false){flag = true;    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实现 compare 和 set 两个操作合在一起的原子性，这也是CAS提供的功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(compareAndSet(false, true)){...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>AtomicReference：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final boolean compareAndSet(V expect, V update){return unsafe.compareAndSwapObject(this, valueOffset, exprct, update);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-2-如何支持-boolean-和-double-类型"><a href="#2-2-2-如何支持-boolean-和-double-类型" class="headerlink" title="2.2.2 如何支持 boolean 和 double 类型"></a>2.2.2 如何支持 boolean 和 double 类型</h3><ul><li>AtomicBoolean 类型怎么支持？</li></ul><p>对于用 int 型来代替的，在入参的时候，将 boolean 类型转换成 int 类型；在返回值的时候，将 int 类型 转换成 boolean 类型。</p><ul><li>double 类型怎么支持？<h2 id="2-3-AtomicStampedReference-和-AtomicMarkanle"><a href="#2-3-AtomicStampedReference-和-AtomicMarkanle" class="headerlink" title="2.3 AtomicStampedReference 和 AtomicMarkanle"></a>2.3 AtomicStampedReference 和 AtomicMarkanle</h2><h3 id="2-3-1-ABA问题与解决方法"><a href="#2-3-1-ABA问题与解决方法" class="headerlink" title="2.3.1 ABA问题与解决方法"></a>2.3.1 ABA问题与解决方法</h3>CAS 都是基于“值”来做比较的。但如果另外一个线程把变量的值从 A 改为 B，再从 B 改回到 A，尽管修改过两次，可是在当前线程做 CAS 操作的时候，却会因为值没变而认为数据没有被其他线程修改过，这就是所谓的<strong>ABA问题</strong>。<br>解决方法：不仅比较“值”，还要比较“版本号”<h3 id="2-3-2-为什么没有-AtomicStampedInteger-AtomictStampedLong"><a href="#2-3-2-为什么没有-AtomicStampedInteger-AtomictStampedLong" class="headerlink" title="2.3.2 为什么没有 AtomicStampedInteger AtomictStampedLong"></a>2.3.2 为什么没有 AtomicStampedInteger AtomictStampedLong</h3>因为要同时比较“值”和“版本号”，而 Integer 型或者 Long 型的 CAS 没有办法同时比较这两个变量，于是只能把值和版本号封装成一个对象，然后通过对象引用的 CAS 来实现。<h3 id="2-3-3-AtomicMarkableReference"><a href="#2-3-3-AtomicMarkableReference" class="headerlink" title="2.3.3 AtomicMarkableReference"></a>2.3.3 AtomicMarkableReference</h3>Pair 里面的版本号是 boolean 类型的，而不是整型的累加变量。因为是 boolean类型，只能有 true、false 两个版本号，所以并不能完全避免 ABA 问题，只是<strong>降低</strong>了 ABA 发生的概率。<h2 id="2-4-AtomicIntegerFieldUpdater、AtomicLongFieldUpdater-和-AtomicReferenceFieldUpdater"><a href="#2-4-AtomicIntegerFieldUpdater、AtomicLongFieldUpdater-和-AtomicReferenceFieldUpdater" class="headerlink" title="2.4 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater"></a>2.4 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater</h2><h3 id="2-4-1-为什么需要-AtomicXXXFieldUpdater"><a href="#2-4-1-为什么需要-AtomicXXXFieldUpdater" class="headerlink" title="2.4.1 为什么需要 AtomicXXXFieldUpdater"></a>2.4.1 为什么需要 AtomicXXXFieldUpdater</h3>如果一个类是自己编写的，则可以在编写的时候把成员变量定义为 Atomic 类型。如果是一个已有的类，在不能更改其源码的情况下，要想实现对其成员变量的原子操作，就需要 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater。<h3 id="2-4-2-限制条件"><a href="#2-4-2-限制条件" class="headerlink" title="2.4.2 限制条件"></a>2.4.2 限制条件</h3>要想使用 AtomicIntegerFieldUpdater 修改成员变量，成员变量必须是 volatile 的 int 类型（不能是 Integer 包装类）<h2 id="2-5-AtomicIntegerArray、AtomicLongArray-和-AtomicReferenceArray"><a href="#2-5-AtomicIntegerArray、AtomicLongArray-和-AtomicReferenceArray" class="headerlink" title="2.5 AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray"></a>2.5 AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray</h2>Concurrent 包提供了 AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray 三个数组元素的原子操作。注：并不是说对整个数组的操作是原子的，而是针对数组中一个元素的原子操作而言。<h3 id="2-5-1-使用方法"><a href="#2-5-1-使用方法" class="headerlink" title="2.5.1 使用方法"></a>2.5.1 使用方法</h3>相比与 AtomicInteger 的 getAndIncrement() 函数，这里只是多了一个传入参数：数组的下标 i<pre class="line-numbers language-java" data-language="java"><code class="language-java">public final boolean compareAndSet(int i, int expect, int update){...}public final int getAndDecrement(int i){...}public final int getAndSet(int i, int newValue){...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-5-2-实现原理"><a href="#2-5-2-实现原理" class="headerlink" title="2.5.2 实现原理"></a>2.5.2 实现原理</h3>其底层的 CAS 函数用的还是 compareAndSwapInt，但是把数组下标 i 转化成对应的内存偏移量，所用的方法和之前的 AtomicInteger 不太一样。<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static longbyteOffset(int i){return ((long) i &lt;&lt; shift) + base;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>把下标 i 换成对应的内存地址，用到 shift 和 base 两个变量。这两个变量都是 AtomicIntegerArray 的静态成员变量，用 Unsafe 类的 arrayBaseOffset 和 arrayIndexScale 两个函数来获取。<br>base 表示数组的首地址的位置，scale 表示一个数组元素的大小，i 的偏移量则等于 i * scale + base。但为了优化性能，使用了位移操作，shift 表示 scale 中 1 的位置（scale 是2的整数次方）。所以，偏移量的计算变成上面代码中的：i &lt;&lt; shift + base，表达的意思就是：i * scale + base。<h2 id="2-6-Striped64-与-LongAdder"><a href="#2-6-Striped64-与-LongAdder" class="headerlink" title="2.6 Striped64 与 LongAdder"></a>2.6 Striped64 与 LongAdder</h2><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627472292002-4bfbcc8d-a019-4c93-8df0-b5a918bfaff5.png#align=left&amp;display=inline&amp;height=208&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=416&amp;originWidth=1458&amp;size=161164&amp;status=done&amp;style=none&amp;width=729" alt="image.png"><br>图 2-2  Striped64 相关的类的继承层次<h3 id="2-6-1-LongAdder-原理"><a href="#2-6-1-LongAdder-原理" class="headerlink" title="2.6.1 LongAdder 原理"></a>2.6.1 LongAdder 原理</h3>AtomicLong 内部是一个 volatile long 型变量，由多个线程对这个变量进行CAS操作。多个线程同时对一个变量进行CAS操作，在高并发的场景下仍不够快，如果再要提高性能，该怎么做？<br>把一个变量拆分成多份，变为多个变量，有些类似于 ConcurrentHashMap 的分段锁的例子。把一个 Long 型拆成一个 base 变量外加多个 Cell，每个 Cell 包装了一个 Long 型变量。当多个线程并发累加的时候，如果并发度低，就直接加到 base 变量上；如果并发度高，冲突大，平摊到这些 Cell 上。在最后取值的时候，再把 base 和这些 Cell 求 sum 运算。<h3 id="2-6-2-最终一致性"><a href="#2-6-2-最终一致性" class="headerlink" title="2.6.2 最终一致性"></a>2.6.2 最终一致性</h3>在 sum 求和函数中，并没有对 cells[] 数组加锁。也就是说，一边有线程对其执行求和操作，一边还有线程修改数组里的值，也就是最终一致性，而不是强一致性。<h3 id="2-6-3-伪共享于缓存行填充"><a href="#2-6-3-伪共享于缓存行填充" class="headerlink" title="2.6.3 伪共享于缓存行填充"></a>2.6.3 伪共享于缓存行填充</h3></li></ul><p><strong>@sun.misc.Contended</strong><br>每个CPU都有自己的缓存。缓存与主内存进行数据交换的基本单位叫 Cache Line（缓存行）。要刷新到主内存的时候，最少要刷新64字节。</p><h3 id="2-6-4-LongAdder-核心实现"><a href="#2-6-4-LongAdder-核心实现" class="headerlink" title="2.6.4 LongAdder 核心实现"></a>2.6.4 LongAdder 核心实现</h3><p>当一个线程调用 add(x) 的时候，首先会尝试使用 casBase 把 x 加到 base 变量上。如果不成功，则再用 a.cas(..) 函数尝试把 x 加到 Cell 数组的某个元素上。如果还不成功，最后再调用 longAccumulate(..) 函数。<br>注：Cell[] 数组的大小始终是2的整数次方，在运行中会不断扩容，每次扩容都是增长2倍。</p><h3 id="2-6-5-LongAccumulator"><a href="#2-6-5-LongAccumulator" class="headerlink" title="2.6.5 LongAccumulator"></a>2.6.5 LongAccumulator</h3><p>LongAccumulator 与 LongAdder 构造函数对比：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public LongAdder() {...}public LongAccumulator(LongBinaryOperator accumulatorFunction, long identity) {...}public interface LongBinaryOperator {long applyAsLong(long left, long right);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>LongAdder 只能进行累加操作，并且初始值默认为0；LongAccumulator 可以自己定义一个二元操作符，并且传入一个初始值。操作符的左值，就是 base 变量或者 Cells[] 中元素的当前值；右值，就是 add() 函数传入的参数 x。</li><li>LongAccumulator 的 accumulate(x) 函数与 LongAdder 的 add(x) 函数类似，最后都是调用 Striped64 的 LongAccumulate(…) 函数。唯一的差别是 LongAdder 的 add(x) 函数调用的是 casBase(b, b+x)，LongAccumulator 调用的是casBase(b, r)，其中，r = function.applyAsLong(b = base, x)。<h3 id="2-6-6-DoubleAdder-与-DoubleAccumulator"><a href="#2-6-6-DoubleAdder-与-DoubleAccumulator" class="headerlink" title="2.6.6 DoubleAdder 与 DoubleAccumulator"></a>2.6.6 DoubleAdder 与 DoubleAccumulator</h3><h1 id="第三章-Lock-与-Condition"><a href="#第三章-Lock-与-Condition" class="headerlink" title="第三章 Lock 与 Condition"></a>第三章 Lock 与 Condition</h1><h2 id="3-1-互斥锁"><a href="#3-1-互斥锁" class="headerlink" title="3.1 互斥锁"></a>3.1 互斥锁</h2><h3 id="3-1-1-锁的可重入性"><a href="#3-1-1-锁的可重入性" class="headerlink" title="3.1.1 锁的可重入性"></a>3.1.1 锁的可重入性</h3>可重入锁（ReentrantX）是指当一个线程调用 object.lock() 拿到锁，进入互斥区后，在此调用 object.lock()，仍然可以拿到该锁。通常的锁都要设计成可重入的，否则会发生死锁。<h3 id="3-1-2-类继承层次"><a href="#3-1-2-类继承层次" class="headerlink" title="3.1.2 类继承层次"></a>3.1.2 类继承层次</h3><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627524371322-ea5e81d2-281f-47f7-af41-a300dc377b4a.png#align=left&amp;display=inline&amp;height=380&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=760&amp;originWidth=1172&amp;size=272917&amp;status=done&amp;style=none&amp;width=586" alt="image.png"><br>图 3-1  与 ReentrantLock 相关类之间的继承关系<br>I 表示界面（Interface），A表示抽象类（Abstract Class），C表示类（Class），$表示内部类。实线表示继承关系，虚线表示引用关系。<br>常用方法 Lock()/unLock()。lock() 不能被中断，对应的 lockInterrupttibly() 可以被中断。<h3 id="3-1-3-锁的公平性-vs-非公平性"><a href="#3-1-3-锁的公平性-vs-非公平性" class="headerlink" title="3.1.3 锁的公平性 vs. 非公平性"></a>3.1.3 锁的公平性 vs. 非公平性</h3>Sync 是一个抽象类，它有两个子类 FairSync 与 NonfairSync，分别对应公平锁和非公平锁<br>一个新的线程来了之后，看到有很多线程在排队，自己排到队伍末尾，这叫公平；线程来了之后直接去抢锁，这叫不公平。默认设置的是非公平锁，为了提高效率，减少线程切换。<h3 id="3-1-4-锁实现的基本原理"><a href="#3-1-4-锁实现的基本原理" class="headerlink" title="3.1.4 锁实现的基本原理"></a>3.1.4 锁实现的基本原理</h3>Sync 的父类 AbstractQueuedSynchronizer 常被称作队列同步器（AQS）<br>为了实现一把具有阻塞或唤醒功能的锁，需要几个核心要素：</li></ul><ol><li>需要一个 state 变量，标记该锁的状态。state 变量至少有两个值：0、1。对 state 变量的操作，要确保线程安全，也就是会用到 CAS。</li><li>需要记录当前是哪个线程持有锁。</li><li>需要底层支持对一个线程进行阻塞或唤醒操作。</li><li>需要有一个队列维护所有阻塞的线程。这个队列也必须是线程安全的无锁队列，也需要用到 CAS。</li></ol><p>state 取值不仅可以是0、1，还可以大于1，就是为了支持锁的可重入性。例如，同样一个线程，调用5次lock，state 会变成5；然后调用5次 unlock，state 减为0.<br>当 state = 0 时，没有线程持有锁，exclusiveOwnerThread = null；<br>当 state = 1 时，有一个线程持有锁，exclusiveOwnerThread = 该线程；<br>当 state &gt; 1 时，说明该线程重入了该锁。</p><p>在当前线程调用 park()，该线程就会堵塞；在另外一个线程中，调用 unpark(Thread t)，传入一个被阻塞的线程，就可以唤醒阻塞在 park() 地方的线程。unpark(Thread t)实现了一个线程对另一个线程的“精准唤醒”。</p><h3 id="3-1-5-公平与非公平的-lock-实现"><a href="#3-1-5-公平与非公平的-lock-实现" class="headerlink" title="3.1.5 公平与非公平的 lock() 实现"></a>3.1.5 公平与非公平的 lock() 实现</h3><h3 id="3-1-6-阻塞队列与唤醒机制"><a href="#3-1-6-阻塞队列与唤醒机制" class="headerlink" title="3.1.6 阻塞队列与唤醒机制"></a>3.1.6 阻塞队列与唤醒机制</h3><p>park() 函数返回有两种情况：<br>情况1：其他线程调用了 unpark(Thread t)<br>情况2：其他线程调用了 t.interrupt()。<strong>注意</strong>，lock()不能响应中断，但LockSupport.park() 会响应中断。</p><h3 id="3-1-7-unlock-实现分析"><a href="#3-1-7-unlock-实现分析" class="headerlink" title="3.1.7 unlock() 实现分析"></a>3.1.7 unlock() 实现分析</h3><p>release() 里面做两件事：tryRelease(..) 函数释放锁；unparkSuccessor(..) 函数唤醒队列中的后继者。<br>因为是排他锁，只有已经持有锁的线程才有资格调用 release(..)，这意味者没有其他线程与它争论。所以在 tryRelease(..) 函数中，对 state 值的修改，不需要CAS操作，直接减1即可。</p><h3 id="3-1-8-lockInterruptibly-实现分析"><a href="#3-1-8-lockInterruptibly-实现分析" class="headerlink" title="3.1.8 lockInterruptibly() 实现分析"></a>3.1.8 lockInterruptibly() 实现分析</h3><p>当 parkAndCheckInterrupt() 返回 true 的时候，说明有其他线程发送中断信号，直接抛出 InterruptedException，跳出 for 循环，整个函数返回。</p><h3 id="3-1-9-tryLock-实现分析"><a href="#3-1-9-tryLock-实现分析" class="headerlink" title="3.1.9 tryLock() 实现分析"></a>3.1.9 tryLock() 实现分析</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean tryLock() {return sync.nonfairTryAcquire(1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>tryLock() 实现基于调用非公平锁的 tryAcquire(..)，对 state 进行 CAS 操作，如果操作成功就拿到锁；如果操作不成功则直接返回 false，也不阻塞。</p><h2 id="3-2-读写锁"><a href="#3-2-读写锁" class="headerlink" title="3.2 读写锁"></a>3.2 读写锁</h2><p>读写锁（ReentrantReadWriteLock）就是读线程和读线程之间可以不用互斥了。</p><h3 id="3-2-1-类继承层次"><a href="#3-2-1-类继承层次" class="headerlink" title="3.2.1 类继承层次"></a>3.2.1 类继承层次</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627554404502-d9bbfa53-1756-433c-ac03-f4e0ca7f0f82.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=532&amp;originWidth=1282&amp;size=60598&amp;status=done&amp;style=none&amp;width=641" alt="image.png"><br>图 3-3  ReentrantReadWriteLock 类继承层次<br>ReentrantWriteLock 实现了该接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ReadWriteLock rwLock = new ReentrantReadWriteLock();Lock rLock = rwLock.readLock();rLock.lock();rLock.unlock();Lock wLock = rwLock.writeLock();wLock.lock();wLock.unlock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-2-读写锁实现的基本原理"><a href="#3-2-2-读写锁实现的基本原理" class="headerlink" title="3.2.2 读写锁实现的基本原理"></a>3.2.2 读写锁实现的基本原理</h3><p>ReadLock 和 WriteLock 是两把锁，实际上是同意把锁的两个视图（读线程和写线程）<br>读线程和读线程不互斥（可以同时拿到这把锁），读线程和写线程互斥，写线程和写线程互斥。<br>当 state = 0 时，说明既没有线程持有读锁，也没有线程持有写锁；当 state != 0 时，要么有线程持有读锁，要么有线程持有写锁，两者不能同时成立，因为读和写互斥。这时再进一步通过 sharedCount(state) 和 exclusiveCount(state) 判断到底是读线程还是写线程持有了该锁。</p><h3 id="3-2-3-AQS-的两对模板方法"><a href="#3-2-3-AQS-的两对模板方法" class="headerlink" title="3.2.3 AQS 的两对模板方法"></a>3.2.3 AQS 的两对模板方法</h3><p>acquire/release、acquireShared/releaseShared 是 AQS 里面的两对模板方法。互斥锁和读写锁的<strong>写锁</strong>都是基于 acquire/release 模板方法来实现的，读写锁的<strong>读锁</strong>都是基于 acquireShared/releaseShared 模板方法来实现的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627558228347-5ddf70e5-8314-4a7b-b47c-1a7860fff866.png#align=left&amp;display=inline&amp;height=358&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=716&amp;originWidth=1024&amp;size=256886&amp;status=done&amp;style=none&amp;width=512" alt="image.png"><br>图 3-4  四种锁的策略的实现示意图<br>最终对应关系：</p><ol><li>读锁的公平实现：Sync.tryAcquireShared() + FairSync 中的两个覆写的子函数。</li><li>读锁的非公平实现：Sync.tryAcquireShared() + NonfairSync 中的两个覆写的子函数。</li><li>写锁的公平实现：Sync.tryAcquire() + FairSync 中的两个覆写的子函数。</li><li>写锁的非公平实现：Sync.tryAcquire() + NonfairSync 中的两个覆写的子函数。</li></ol><p>对于公平，不论是读锁，还是写锁，只要队列中有其他线程在排队，就不能直接去抢锁，要排在队列尾部。<br>对于非公平，读锁和写锁的实现策略略有差异。<strong>写锁</strong>，写线程能抢锁，前提是 state = 0，只有在没有其他线程持有读锁或写锁的情况下，它才有机会去抢锁。当 state != 0，由于持有写锁线程，再次重入。写线程是非公平的，不断去抢（一直返回 false）。但对于读线程，读线程和读线程不互斥的，对于读线程的非公平，要做一些“约束”。当发现队列的第一个元素是写线程，读线程要阻塞一下。</p><h3 id="3-2-4-WriteLock-公平-vs-非公平实现"><a href="#3-2-4-WriteLock-公平-vs-非公平实现" class="headerlink" title="3.2.4 WriteLock 公平 vs. 非公平实现"></a>3.2.4 WriteLock 公平 vs. 非公平实现</h3><ol><li>tryAcquire() 实现分析</li></ol><ul><li>if(c != 0) and w == 0，说明当前一定是读线程拿着锁，写锁一定拿不到，返回false。</li><li>if(c != 0) and w != 0，说明当前一定是写线程拿着锁，执行 current != getExclusiveOwnerThread() 的判断，发现 ownerThread 不是自己，返回 false。</li><li>if(c != 0) and w == 0，且 curent = getExclusiveOwnerThread()，才会走到 if(w + exclusiveCount(acquires) &gt; MAX_COUNT)。判断重入次数，重入次数超过最大值，抛出异常。</li><li>if(c = 0)，说明当前既没有读线程，也没有写线程持有该锁。可以通过CAS操作开抢，抢成功后，调用 setExclusiveOwnerThread(current)，把 ownerThread 设成自己</li></ul><ol start="2"><li>tryRelease(..) 实现分析</li></ol><p>因为写锁是排他的，在当前线程持有写锁的时候，其他线程既不会持有写锁，也不会持有读锁。所以，这里对 state 值的调减不需要 CAS 操作，直接减一即可。</p><h3 id="3-2-5-ReadLock-公平-vs-非公平实现"><a href="#3-2-5-ReadLock-公平-vs-非公平实现" class="headerlink" title="3.2.5 ReadLock 公平 vs. 非公平实现"></a>3.2.5 ReadLock 公平 vs. 非公平实现</h3><ol><li><p>tryAcquireShared(..) 实现分析</p></li><li><p>tryReleaseShared(..) 实现分析</p><h2 id="3-3-Condition"><a href="#3-3-Condition" class="headerlink" title="3.3 Condition"></a>3.3 Condition</h2><h3 id="3-3-1-Condition-与-Lock-的关系"><a href="#3-3-1-Condition-与-Lock-的关系" class="headerlink" title="3.3.1 Condition 与 Lock 的关系"></a>3.3.1 Condition 与 Lock 的关系</h3><p>Condition 本身也是接口，其功能和 wait/notify 类似<br>Condition 必须和 Lock 一起使用</p><h3 id="3-3-2-Condition-的使用场景"><a href="#3-3-2-Condition-的使用场景" class="headerlink" title="3.3.2 Condition 的使用场景"></a>3.3.2 Condition 的使用场景</h3><p>一个用数组实现的阻塞队列，执行 put(..) 操作的时候，队列满了，生产者线程被阻塞；执行 take() 操作的时候，队列为空，消费者线程被阻塞。</p><h3 id="3-3-3-Condition-实现原理"><a href="#3-3-3-Condition-实现原理" class="headerlink" title="3.3.3 Condition 实现原理"></a>3.3.3 Condition 实现原理</h3><p>读写锁中的 ReadLock 是不支持 Condition 的，读写锁的写锁和互斥锁都支持 Condition。虽然它们都调用的是自己的内部类 Sync，但内部类 Sync 都继承子、自 AQS。</p><h3 id="3-3-4-await-实现分析"><a href="#3-3-4-await-实现分析" class="headerlink" title="3.3.4 await() 实现分析"></a>3.3.4 await() 实现分析</h3></li><li><p>线程调用 await() 的时候，肯定已经拿到了锁。</p></li><li><p>在线程执行 wait 操作之前，必须先释放锁。</p></li><li><p>线程从 wait 中被唤醒后，必须用 acquireQueued(node, savedState) 函数重新拿锁。</p></li><li><p>checkInterruptWhileWaiting(node) 代码在 park(this) 代码之后，是为了检测在 park 期间是否收到过中断信号。</p></li><li><p>isOnSyncQueue(node) 用于判断该 Node 是否在 AQS 的同步队列里。</p><h3 id="3-3-5-awaitUninterruptibly-实现分析"><a href="#3-3-5-awaitUninterruptibly-实现分析" class="headerlink" title="3.3.5 awaitUninterruptibly() 实现分析"></a>3.3.5 awaitUninterruptibly() 实现分析</h3><p>awaitUninterruptibly() 不会响应中断，其函数的定义不会有中断异常抛出，继续执行 while 循环。</p><h3 id="3-3-6-notify-实现分析"><a href="#3-3-6-notify-实现分析" class="headerlink" title="3.3.6 notify() 实现分析"></a>3.3.6 notify() 实现分析</h3><p>在调用 notify() 的时候，必须先拿到锁，然后从队列中取出 firstWait，唤醒它。</p><h2 id="3-4-StampedLock"><a href="#3-4-StampedLock" class="headerlink" title="3.4 StampedLock"></a>3.4 StampedLock</h2><h3 id="3-4-1-为什么引入-StampedLock"><a href="#3-4-1-为什么引入-StampedLock" class="headerlink" title="3.4.1 为什么引入 StampedLock"></a>3.4.1 为什么引入 StampedLock</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627607333589-9265d52d-df36-40eb-aa83-6f4cacebb61d.png#align=left&amp;display=inline&amp;height=140&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=280&amp;originWidth=1464&amp;size=46273&amp;status=done&amp;style=none&amp;width=732" alt="image.png"><br>图 3-1  三种锁的并发度对比<br>因为 ReentrantLock 采用的“悲观锁”的策略。当第一个线程拿到锁之后，第二个、第三个读线程还可以拿到锁，使得写线程一直拿不到锁，可能导致写线程“饿死”。虽然在其公平或非公平的实现中，都尽量避免这种情形，但还是有可能发生。StampedLock 引入了“乐观锁策略”，读的时候不加锁，读出来发现数据被修改了，再升级为“悲观锁”，相当于降低了“读”的地位，把抢锁的天平往“写”的一方倾斜了一下，避免写线程被锁死。</p><h3 id="3-4-2-使用场景"><a href="#3-4-2-使用场景" class="headerlink" title="3.4.2 使用场景"></a>3.4.2 使用场景</h3><p>首先，执行 move 操作的时候，要加写锁，写操作和写操作也是互斥的。关键在于读的时候，用了一个“乐观锁”sl.tryOptimisticRead()，相当于在读之前给数据的状态做了一个“快照”。然后，把数据拷贝到内存里面，再用之前，再对比一次版本号。如果版本号变了，则说明在读的期间有其他线程修改了数据。读出来的数据废弃，重新获取读锁。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">long stamp = sl.tryOptimisticRead();//在读之前，获取数据版本号double currentX = x, currentY = y;//读：将一份数据拷贝到线程的栈内存中if (!sl.validate(stamp)){...}//读之后：判断读出来数据是否可以使用（所谓可以使用，是指读的期间没有其他线程修改过数据）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这三行关键代码对顺序非常敏感，不能有重排序。因为 state 变量已经是 volatile，所以可以禁止重排序，但 stamp 并不是 volatile 的。为此，在 volatile(stamp) 函数里面插入<strong>内存屏障</strong></p><h3 id="3-4-3-“乐观锁”的实现原理"><a href="#3-4-3-“乐观锁”的实现原理" class="headerlink" title="3.4.3 “乐观锁”的实现原理"></a>3.4.3 “乐观锁”的实现原理</h3><h3 id="3-4-4-悲观锁-写：“阻塞”与“自旋”策略实现差异"><a href="#3-4-4-悲观锁-写：“阻塞”与“自旋”策略实现差异" class="headerlink" title="3.4.4 悲观锁/写：“阻塞”与“自旋”策略实现差异"></a>3.4.4 悲观锁/写：“阻塞”与“自旋”策略实现差异</h3><h1 id="第四章-同步工具类"><a href="#第四章-同步工具类" class="headerlink" title="第四章 同步工具类"></a>第四章 同步工具类</h1><h2 id="4-1-Semaphore"><a href="#4-1-Semaphore" class="headerlink" title="4.1 Semaphore"></a>4.1 Semaphore</h2><p>Semaphore 也就是信号量，提供了资源数量的并发访问控制<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627613239272-6e8be334-c32d-4e30-8cda-f15d006180bf.png#align=left&amp;display=inline&amp;height=291&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=582&amp;originWidth=922&amp;size=171058&amp;status=done&amp;style=none&amp;width=461" alt="image.png"><br>图 4-1  Semaphore 相关类的继承体系</p><h2 id="4-2-CountDownLatch"><a href="#4-2-CountDownLatch" class="headerlink" title="4.2 CountDownLatch"></a>4.2 CountDownLatch</h2><p>因为是基于AQS阻塞队列实现的，所以可以让多个线程阻塞在 state = 0 条件上，通过 countDown() 一直累减 state，减到0后一次性唤醒所有线程。<br>假设初始总数为M，N个线程 await()，M个线程countDown()，减到0之后，N个线程被唤醒。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627614623869-84a05c1a-9e1f-46cf-8540-2e6add340093.png#align=left&amp;display=inline&amp;height=164&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=328&amp;originWidth=1184&amp;size=161694&amp;status=done&amp;style=none&amp;width=592" alt="image.png"><br>图 4-3  多个线程阻塞在 await() 示意图</p><h3 id="4-2-1-CountDownLatch-使用场景"><a href="#4-2-1-CountDownLatch-使用场景" class="headerlink" title="4.2.1 CountDownLatch 使用场景"></a>4.2.1 CountDownLatch 使用场景</h3><p>一个主线程要等待10个 Worker 线程工作完毕才退出，就能使用 CountDownLatch 来实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">CountDownLatch doneSignal = new CountDownLatch(10);//初始为10doneSignal.await();//主线程调用该方法，阻塞在这doneSignal.countDown();//10个Worker线程，每个线程工作完毕后，调用1次countDown()，计算器减1。当减到0之后，主线程被唤醒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627613787116-34d14399-f88f-4f45-9140-7fc01032eb06.png#align=left&amp;display=inline&amp;height=217&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=434&amp;originWidth=1030&amp;size=134647&amp;status=done&amp;style=none&amp;width=515" alt="image.png"><br>图 4-2  CountDownLatch 相关类的继承层次</p><h3 id="4-2-2-await-实现分析"><a href="#4-2-2-await-实现分析" class="headerlink" title="4.2.2 await() 实现分析"></a>4.2.2 await() 实现分析</h3><p>await() 调用的是AQS模版方法<br>从 tryAcquireShared(..) 方法的实现来看，只要 state != 0，调用 await() 方法的线程便会被释放入AQS的阻塞队列，进入阻塞状态。</p><h3 id="4-2-3-countDown-实现分析"><a href="#4-2-3-countDown-实现分析" class="headerlink" title="4.2.3 countDown() 实现分析"></a>4.2.3 countDown() 实现分析</h3><p>countDown() 调用的AQS的模版方法 releaseShared()，里面的 tryReleaseShared(..) 被 CountDownLatch.Sync 重新实现。只有 state = 0，tryReleaseShared(..) 才会返回 true，然后执行 doReleaseShared(..)，一次性唤醒队列中所有阻塞的线程。</p><h2 id="4-3-CyclicBarrier"><a href="#4-3-CyclicBarrier" class="headerlink" title="4.3 CyclicBarrier"></a>4.3 CyclicBarrier</h2><h3 id="4-3-1-CyclicBarrier-使用场景"><a href="#4-3-1-CyclicBarrier-使用场景" class="headerlink" title="4.3.1 CyclicBarrier 使用场景"></a>4.3.1 CyclicBarrier 使用场景</h3><p>等待所有线程到达同步点再开始下一个阶段。</p><h3 id="4-3-2-CyclicBarrier-实现分析"><a href="#4-3-2-CyclicBarrier-实现分析" class="headerlink" title="4.3.2 CyclicBarrier 实现分析"></a>4.3.2 CyclicBarrier 实现分析</h3></li><li><p>CyclicBarrier 是可以被重用的。所有线程互相等待，到齐后一起被唤醒各自执行接下来的逻辑。每一轮被称为一个 Generation，就是一个同步点</p></li><li><p>CyclicBarrier 会响应中断。线程没有到齐，如果收到中断信号，所有阻塞线程会被唤醒，就是 breakBarrier() 函数。然后 count 被重置为初始值（parties），重新开始。</p></li><li><p>barrierAction 只会被执行一次。</p><h2 id="4-4-Exchanger"><a href="#4-4-Exchanger" class="headerlink" title="4.4 Exchanger"></a>4.4 Exchanger</h2><h3 id="4-4-1-Exchanger-使用场景"><a href="#4-4-1-Exchanger-使用场景" class="headerlink" title="4.4.1 Exchanger 使用场景"></a>4.4.1 Exchanger 使用场景</h3><p>Exchanger 用于线程之间交换数据</p><h3 id="4-4-2-Exchanger-实现原理"><a href="#4-4-2-Exchanger-实现原理" class="headerlink" title="4.4.2 Exchanger 实现原理"></a>4.4.2 Exchanger 实现原理</h3><p>Exchanger 的核心机制和 Lock 一样，也是 CAS + park/unpark。<br>每个线程在调用 exchange(..) 函数交换数据的时候，会先创建一个 Node 对象，这个 Node 对象就是对该线程的包装，里面包含了两个字段：1个是线程要交互的数据，另1个是该线程自身。<strong>注：Node 本身是继承自AtomicReference 的，所以除了这两个字段，Node 还有第3个字段，记录的是对方所要交换的数据，初始为 NULL。</strong><br>Slot 的 AtomicReference 就是指向的一个 Node，通过 Slot 和 Node 相结合，实现了2个线程之间的数据交换。线程1持有数据 item1，线程2持有数据 item2，各自调用 exchange(..)，会各自生成一个 Node。而 Slot 只会指向2个 Node 中的1个：如果是线程1先调用的 exchange(..)，那么 Slot 就指向 Node1 ，线程1阻塞，等待线程2来交换；反之，如果是线程2先调用的 exchange(..) ，那么 Slot 就指向 Node2，线程2阻塞，等待线程1来交换数据。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627616545389-1eab47a9-d671-4800-aa15-82146c306660.png#align=left&amp;display=inline&amp;height=183&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=366&amp;originWidth=1400&amp;size=165648&amp;status=done&amp;style=none&amp;width=700" alt="image.png"><br>图 4-3  Slot 与 Node 相结合实现2个线程交换数据<br>一个 Slot 只能支持2个线程之间交换数据，要实现多个线程并行地交换数据，需要多个Slot，因此在 Exchange 里面定义了 Slot 数组：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private volatile Slot[] arena = new Slot[CAPACITY];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-4-3-exchanger-V-x-实现分析"><a href="#4-4-3-exchanger-V-x-实现分析" class="headerlink" title="4.4.3 exchanger(V x) 实现分析"></a>4.4.3 exchanger(V x) 实现分析</h3><h2 id="4-5-Phaser"><a href="#4-5-Phaser" class="headerlink" title="4.5 Phaser"></a>4.5 Phaser</h2><h3 id="4-5-1-用-Phaser-替代-CyclicBarrier-和-CountDownLatch"><a href="#4-5-1-用-Phaser-替代-CyclicBarrier-和-CountDownLatch" class="headerlink" title="4.5.1 用 Phaser 替代 CyclicBarrier 和 CountDownLatch"></a>4.5.1 用 Phaser 替代 CyclicBarrier 和 CountDownLatch</h3></li><li><p>用 Phaser 替代 CyclicBarrier</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Phaser ph = new Phaser(10);//初始为10ph.awaitAdance(ph.getPhase());//主线程调用该方法，阻塞在这。ph.arrive();//每个线程工作完成之后，调用1次arrive()。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>用 Phaser 替代 CountDownLatch</p><h3 id="4-5-2-Phaser-新特性"><a href="#4-5-2-Phaser-新特性" class="headerlink" title="4.5.2 Phaser 新特性"></a>4.5.2 Phaser 新特性</h3><p>特性1：动态调整线程个数<br>CyclicBarrier 所要同步的线程个数是在构造函数中指定的，之后不能更改。而 Phaser 可以在运行期间动态地调整要同步的线程个数。</p></li></ol><p>特性2：层次 Phaser<br>父 Phaser 并不用感知子 Phaser 的存在，当子 Phaser 中注册的参与者数量大于0时，会把自己向父节点注册；当子 Phaser 中注册的参与者数量等于0时，会自动向父节点解注册。父 Phaser 把子 Phaser 当作一个正常参与的线程就可以了。</p><h3 id="4-5-3-state-变量解析"><a href="#4-5-3-state-变量解析" class="headerlink" title="4.5.3 state 变量解析"></a>4.5.3 state 变量解析</h3><p>state 变量在构造函数中是如何赋值的？</p><ul><li>当 parties = 0 时，state 被赋予一个 EMPTY 常量，常量为1；</li><li>当 parties != 0 时，把 phase 值左移32位；把 parties 左移16位；然后 parties 也作为最低的16位，3个值做或操作，赋值给 state。<h3 id="4-5-4-阻塞与唤醒（Treiber-Strack）"><a href="#4-5-4-阻塞与唤醒（Treiber-Strack）" class="headerlink" title="4.5.4 阻塞与唤醒（Treiber Strack）"></a>4.5.4 阻塞与唤醒（Treiber Strack）</h3>基于上述的 state 变量，对其执行 CAS 操作，并进行相应的阻塞与唤醒。右边的主线程会调用 awaitAdcance() 进行阻塞；左边的 arrive() 会对 state 进行 CAS 的累减操作，当未到达的线程数减到0时，唤醒右边阻塞的主线程。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627617608223-bdb01b47-380d-4670-b33c-8e619d85299e.png#align=left&amp;display=inline&amp;height=174&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=348&amp;originWidth=1200&amp;size=149015&amp;status=done&amp;style=none&amp;width=600" alt="image.png"><br>图 4-10  基于 state 的 CAS 的阻塞与唤醒示意图<h3 id="4-5-5-arrive-函数分析"><a href="#4-5-5-arrive-函数分析" class="headerlink" title="4.5.5 arrive() 函数分析"></a>4.5.5 arrive() 函数分析</h3>arrive() 和 arriveAndDeregister() 内部调用的都是 doArrive(boolean)函数。arrive() 把“未达到线程数”减1； arriveAndDeregister() 把“未到达线程数”和“下一轮的总线程数”都减1.<h3 id="4-5-6-awaitAdvance-函数分析"><a href="#4-5-6-awaitAdvance-函数分析" class="headerlink" title="4.5.6 awaitAdvance() 函数分析"></a>4.5.6 awaitAdvance() 函数分析</h3><h1 id="第五章-并发容器"><a href="#第五章-并发容器" class="headerlink" title="第五章 并发容器"></a>第五章 并发容器</h1><h2 id="5-1-BlockingQueue"><a href="#5-1-BlockingQueue" class="headerlink" title="5.1 BlockingQueue"></a>5.1 BlockingQueue</h2>在所有的并发容器中，BlockingQueue 是最常见的一种。BlockingQueue 是一个带阻塞功能的队列当入队列时，若队列已满，则阻塞调用者；当出队列时，若队列为空，则阻塞调用者。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627629198547-f0abef5c-0260-4a0f-b015-68dca993a9df.png#align=left&amp;display=inline&amp;height=149&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=298&amp;originWidth=1316&amp;size=121006&amp;status=done&amp;style=none&amp;width=658" alt="image.png"><br>图 5-1  BlockingQueue 的各种实现类<h3 id="5-1-1-ArrayBlockingQueue"><a href="#5-1-1-ArrayBlockingQueue" class="headerlink" title="5.1.1 ArrayBlockingQueue"></a>5.1.1 ArrayBlockingQueue</h3>ArrayBlockingQueue 是一个用数组实行的环形队列，在构造函数中，会要求传入数组的容量。<pre class="line-numbers language-java" data-language="java"><code class="language-java">public ArrayBlockingQueue(int capacity, boolean fair) {...}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-1-2-LinkedBlockingQueue"><a href="#5-1-2-LinkedBlockingQueue" class="headerlink" title="5.1.2 LinkedBlockingQueue"></a>5.1.2 LinkedBlockingQueue</h3>LinkedBlockingQueue 是一种基于单向链表的阻塞队列。因为队头和队尾是2个指针分开操作的，所以用了2把锁 + 2个条件，同时有1个 AtomicInteger 的原子变量记录 count 数。<br>LinkedBlockingQueue 和 ArrayBlockingQueue 的实现差异：</li></ul><ol><li><p>为了提高并发度，用2把锁，分别控制队头、队尾的操作。意味着在 put(..) 和 put(..) 之间、take(..) 和 take(..) 之间互斥的，put(..) 和 take(..) 之间并不互斥的。但对于 count 变量，双方都需要操作，所以必须是原子类型。</p></li><li><p>因为各自拿了一把锁，所以当需要调用对方的 condition 的 signal 时，还必须再加上对方的锁，就是 signalNotEmpty() 和 signalNotFull() 函数。</p></li><li><p>不仅 put 会通知 take，take 也会通知 put。当 put 发现非满时，也会通知其他 put 线程；当 take 发现非空的时候，也会通知其他 take 线程。</p><h3 id="5-1-3-PriorityBlockingQueue"><a href="#5-1-3-PriorityBlockingQueue" class="headerlink" title="5.1.3 PriorityBlockingQueue"></a>5.1.3 PriorityBlockingQueue</h3><p>队列通常是先进先出的，而 PriorityQueue 是按照元素的优先级从小到大出队列的。PriorityQueue 中的2个元素之间需要可以比较大小，并实现 Comparable 接口。<br>在阻塞的实现方面，和 ArrayBlockingQueue 的机制相似，主要区别是用数组实现了一个二叉堆，从而实现按优先级从小到大出队列。另一个区别是没有 notFull 条件，当元素个数超过数组长度时，执行扩容操作。</p><h3 id="5-1-4-DelayQueue"><a href="#5-1-4-DelayQueue" class="headerlink" title="5.1.4 DelayQueue"></a>5.1.4 DelayQueue</h3><p>DelayQueue 即延迟队列，也就是一个按延迟时间从小到大出队的 PriorityQueue。所谓延迟时间，就是“未来将要执行的时间” - “当前时间”。为此，放入 DelayQueue 中的元素，必须实现 Delayed 接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Delayed extends Comparable&lt;Delayed&gt;{long getDelay(TimeUnit unit);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关于该接口，有两点说明：</p></li><li><p>如果 getDelay 的返回值小于或等于0，则说明该元素到期，需要从队列中拿出来执行。</p></li><li><p>该接口首先继承了 Comparable 接口，所以要实现该接口，必须实现 Comparable 接口</p></li></ol><p>不是每放入一个元素，都需要通知等待的线程。放入的元素，如果其延迟时间大于当前堆顶的元素延迟时间，就没必要通知等待的线程；只有当延迟时间是最小的，在堆顶时，才有必要通知等待的线程，也就是上面代码中的 if(q.peek()==e)段落。</p><h3 id="5-1-5-SynchronousQueue"><a href="#5-1-5-SynchronousQueue" class="headerlink" title="5.1.5 SynchronousQueue"></a>5.1.5 SynchronousQueue</h3><p>SynchronousQueue 是一种特殊的 BlockingQueue，它本身没有容量。先调 put(..)，线程会阻塞；直到另一个线程调用 take()，两个线程才同时解锁，反之亦然。<br>如果是公平模式，则用 TransferQueue 实现；如果是非公平模式，则用 TransferStack 实现。put/take 都调用了 transfer(..) 接口。而 TransferQueue 和 TransferStack 分别实现了这个接口。该接口在 SynchronousQueue 内部。如果是 put(..)，则第1个参数就是对应的元素；如果是 take()，则是第1个为 null。后2个参数分别为是否设置超时和对应的超时时间。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">abstract static class Transferer{abstract Object transfer(Object e, boolean timed, long nanos);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>TransferQueue</li></ol><p>TransferQueue 是一个基于单向链表而实现的队列，通过 head 和 tail 2个指针记录头部和尾部。初始的时候，head 和 tail 会指向一个空节点。<br>TransferQueue 的工作原理<br>阶段(a)：队列中是一个空的节点，head/tail都指向这个空节点。<br>阶段(b)：3个线程分别调用 put，生成3个 QNode，进入队列。<br>阶段(c)：来了一个线程调用 take，会和队列头部的第1个 QNode 进行配对。<br>阶段(d)：第1个 QNode 出队列。<br><strong>关键点：</strong>put 节点和 take 节点一旦相遇，就会配对出队列，所以在队列中不可能同时存在 put 节点和 take 节点，要么所有节点都是 put 节点，要么所有节点都是 take 节点。</p><ol start="2"><li>TransferStack</li></ol><p>TransferStack 是一个单向链表，只需要 head 指针就能实现入栈和出栈操作。链表中的节点有三种状态，REQUEST 对应 take 节点，DATE 对应 put 节点，二者配对后，会生成一个 FULFILLING 节点，入栈，然后 FULLING 节点和被配对的节点一起出栈。<br>TransferStack 的工作原理<br>阶段(a)：head 指向 NULL。不同于 TransferQueue，这里没有空的头节点。<br>阶段(b)：3个线程调用3次 put，依次入栈。<br>阶段(c)：线程4调用 take，和栈顶的第1个元素配对，生成 FULLFILLING 节点，入栈。<br>阶段(d)：栈顶的2个元素同时入栈。</p><h2 id="5-2-BlockingDeque"><a href="#5-2-BlockingDeque" class="headerlink" title="5.2 BlockingDeque"></a>5.2 BlockingDeque</h2><p>BlockingDeque 定义了一个阻塞的双端队列接口。该接口继承了 BlockingQueue 接口的同时，增加对应双端队列操作接口。该接口只有一个实现，就是 LinkedBlockingDeque</p><h2 id="5-3-CopyOnWrite"><a href="#5-3-CopyOnWrite" class="headerlink" title="5.3 CopyOnWrite"></a>5.3 CopyOnWrite</h2><p>CopyOnWrite 指在“写”的时候，不是直接“写”源数据，而是把数据拷贝一份进行修改，再通过悲观锁或者乐观锁的方式写回。</p><h3 id="5-3-1-CopyOnWriteArrayList"><a href="#5-3-1-CopyOnWriteArrayList" class="headerlink" title="5.3.1 CopyOnWriteArrayList"></a>5.3.1 CopyOnWriteArrayList</h3><h3 id="5-3-2-CopyOnWriteArraySet"><a href="#5-3-2-CopyOnWriteArraySet" class="headerlink" title="5.3.2 CopyOnWriteArraySet"></a>5.3.2 CopyOnWriteArraySet</h3><p>CopyOnWriteArraySet 就是用 Array 实现的一个 Set，保证所有元素都不重复。</p><h2 id="5-4-ConcurrentLinkedQueue-Deque"><a href="#5-4-ConcurrentLinkedQueue-Deque" class="headerlink" title="5.4 ConcurrentLinkedQueue/Deque"></a>5.4 ConcurrentLinkedQueue/Deque</h2><ol><li>初始化</li></ol><p>初始化的时候，head 和 tail 都执行一个 NULL 节点。</p><ol start="2"><li>入队列</li></ol><p>初始的时候，队列中有1个节点 item1，tail 指向该节点，假设线程1要入队 item2 节点：<br>step1：p = tail，q = p.next = NULL。<br>step2：对p的 next 执行 CAS 操作，追加 item2，成功之后，p = tail。所以上面的 casTail 函数不会执行，直接返回。此时 tail 指针没有变化。<br>step3：p = tail，q = p.next。<br>step4：q != NULL，因此不会入队新节点。p，q都后移1位。<br>step5：q = NULL，对p的 next 执行 CAS 操作，入队 item3 节点。<br>step6：p != t，满足条件，执行上面的 casTail 操作，tail 后移2个位置，到达队列尾部。<br>关键点：</p><ul><li>即使 tail 指针没有移动，只要对p的 next 指针成功进行 CAS 操作，就算成功入队列。</li><li>只有当 p != tail 的时候，才会后移 tail 指针。也就是说，每连续追加2个节点，才后移1次 tail 指针。即使 CAS 失败，也可以由下一个线程来移动 tail 指针。</li></ul><ol start="3"><li>出队列</li></ol><p>假设初始的时候 head 指向空节点，队列中有 item1，item2，item3 三个节点。<br>step1：p = head，q = p.next，p != q。<br>step2：后移p指针，使得 p = q。<br>step3：出队列。关键点：此处并没有直接删除 item1 节点，只是把该节点的 item 通过 CAS 操作置为了 NULL。<br>step4：p != head，此时队列中有了2个 NULL 节点，，再前移1次 head 指针，对其进行 updateHead 操作。<br>关键点：</p><ul><li>出队列的判断并非观察 tail 指针的位置，而是依赖于 head 指针后续的节点是否为 NULL 这一条件。</li><li>只要对节点的 item 执行 CAS 操作，置为 NULL 成功，则出队列成功。即使 head 指针没有成功移动，也可以由下一个线程继续完成。</li></ul><ol start="4"><li>队列判空</li></ol><p>因为 head/tail 并不是精确地指向队列头部和尾部，所以不能简单地通过比较 head/tail 指针来判断队列是否为空，而是需要从 head 指针开始遍历，找第1个不为 NULL 的节点。如果找到，则队列不为空；如果找不到，则队列为空。</p><h2 id="5-5-ConcurrentHashMap"><a href="#5-5-ConcurrentHashMap" class="headerlink" title="5.5 ConcurrentHashMap"></a>5.5 ConcurrentHashMap</h2><p>HashMap 通常的实现方式是“数组 + 链表”，这种方式被称为“拉链法”。</p><h3 id="5-5-1-JDK7-中的实现方式"><a href="#5-5-1-JDK7-中的实现方式" class="headerlink" title="5.5.1 JDK7 中的实现方式"></a>5.5.1 JDK7 中的实现方式</h3><ol><li>构造函数分析<ol><li>第1个参数，initialCapacity 是整个 ConcurrentHashMap 的初始大小。用 initialCapacity 除以 ssize，是每个 Segment 的初始大小。这里也会保证 Segment 里面 HashEntry[] 数组的大小是2的整数次方。</li><li>第2个参数，loadFactor 即负载因子，传给了 Segment 内部。当每个 Segment 的元素达到一定阀值，进行 rehash。Segment 的个数不能扩容，但每个 Segment 的内部可以扩容。</li><li>第3个参数，concurrenyLevel 是“并发度”，也就是 Segment 数组的大小。这个值一旦在构造函数中设定，之后不能再扩容。为了提升 hash 的计算性能，会保证数组的大小始终是2的整数次方。</li></ol></li><li>put(..) 函数分析</li></ol><p>进入 scanAndLockForPut(key, hash, value) 做什么？<br>一是拿不到锁，不立即阻塞，而是先自旋，若自旋到一定次数仍未拿到锁，再调用 lock() 阻塞；<br>二是在自旋的过程中遍历了链表，若发现没有重复的节点，则提前新建一个节点，为后面再插入节省时间。</p><ol start="3"><li>扩容<ol><li>函数的参数，也就是将要加入的最新节点。在扩容完成之后，把该节点加入新的 Hash 表。</li><li>整个数组的长度是2的整数次方，每次按二倍扩容，而 hash 函数就是对数组长度取模，即 node.hash &amp; sizeMask。因此，如果元素之前处于第i个位置，当再次 hash 时，必然处于第i个或第 i+oldCapacity 个位置。</li><li>lastRun 到链表末尾的所有元素，其 hash 值没有改变，所以不需要依次重新拷贝，只需把这部分链表链接到新链表锁对应的位置就可以，也就是 new Table[lastIdx] = lastRun。lastRun 之前的元素则需要依次拷贝</li></ol></li><li>get 实现分析</li></ol><p>整个 get 过程是两次 hash</p><ol><li>第一次 hash，函数为 (h&gt;&gt;&gt;segmentShift) &amp; segmentMask，计算出所在的 Segment；</li><li>第二次 hash，函数为 h &amp; (tab.length -  1)，即h对数组长度取模，找到 Segment 里面对应的 HashEntry 数组下标，然后遍历该位置的链表</li></ol><p>整个读过程完全没有加锁，而是使用了 UNSAFE.getObjectVolatile 函数。</p><h3 id="5-5-2-JDK8-中的实现方式"><a href="#5-5-2-JDK8-中的实现方式" class="headerlink" title="5.5.2 JDK8 中的实现方式"></a>5.5.2 JDK8 中的实现方式</h3><p>链表和红黑树之间可以相互转换：初始的时候是链表，当链表中的元素超过某个阀值时，把链表转换成红黑树；反之，当红黑树中的元素个数小于某个阀值，再转换为链表。<br>为什么 JDK8 要做这种改变？在 JDK7 中的分段锁，有三个好处：</p><ol><li>减少 Hash 冲突，避免一个槽里有太多元素。</li><li>提高读和写的并发度。段与段之间相互独立。</li><li>提供扩容的并发度。扩容的时候，不是整个 ConcurrentHashMap 一起扩容，而是每个 Segment 独立扩容。</li></ol><p>针对这三个好处，JDK8 相应的处理方式：</p><ol><li>使用红黑树，当一个槽里有很多元素时，其查询和更新速度会比链表快很多，Hash 冲突的问题由此得到很好的解决。</li><li>加锁的粒度，并非整个 ConcurrentHashMap，而是对每个头节点分别加锁，即并发度，就是 Node 数组长度，初始长度为16，和在 JDK7 中初始 Segment 的个数相同。</li><li>并发扩容，在 JDK7 中，一旦 Segment 的个数在初始化的时候确立，不能再更改，并发度被固定。之后只是在每个 Segment 内部扩容，这意味着每个 Segment 独立扩容，互不影响，不存在并发扩容的问题。在 JDK8 中，相当于只有1个 Segment，当一个线程要扩容 Node 数组的时候，其他线程还要读写。<h2 id="5-6-ConcurrentSkipListMap-Set"><a href="#5-6-ConcurrentSkipListMap-Set" class="headerlink" title="5.6 ConcurrentSkipListMap/Set"></a>5.6 ConcurrentSkipListMap/Set</h2>ConcurrentSkipListMap 是一个 key 无序的 HashMap，HashMap 则是 key 有序的，实现了 NavigableMap 接口，此接口又继承了 SortedMap 接口。<h3 id="5-6-1-ConcurrentSkipListMap"><a href="#5-6-1-ConcurrentSkipListMap" class="headerlink" title="5.6.1 ConcurrentSkipListMap"></a>5.6.1 ConcurrentSkipListMap</h3>为什么要使用 SkipList 实现 Map？<br>在 Java 的 util 包中，有一个非线程安全的 HashMap，也就是 TreeMap，是 key 有序的，基于红黑树实现。而在 Concurrent 包中，提供的 key 有序的 HashMap，也就是 ConcurrentSkipMap，是基于 SkipList（调查表）来实现的。<h3 id="5-6-2-ConcurrentSkipListSet"><a href="#5-6-2-ConcurrentSkipListSet" class="headerlink" title="5.6.2 ConcurrentSkipListSet"></a>5.6.2 ConcurrentSkipListSet</h3><h1 id="第六章-线程池与-Future"><a href="#第六章-线程池与-Future" class="headerlink" title="第六章 线程池与 Future"></a>第六章 线程池与 Future</h1><h2 id="6-1-线程池的实现原理"><a href="#6-1-线程池的实现原理" class="headerlink" title="6.1 线程池的实现原理"></a>6.1 线程池的实现原理</h2>当没有任务的时候，线程是进入睡眠一小段时间？还是进入阻塞？如果进入阻塞，如何让唤醒？</li></ol><ul><li>做法1：不使用阻塞队列，只使用一般的线程安全的队列，也无阻塞—唤醒机制。当队列为空时，线程池中的线程只能睡眠一会，然后醒来去看队列中有没有新任务到来，如此不断轮询。</li><li>做法2：不使用阻塞队列，但在队列外部、线程池内部实现了阻塞—唤醒机制。</li><li>做法3：使用阻塞队列</li></ul><p>做法3最完善，既避免了线程池内部自己实现阻塞—唤醒机制的麻烦，也避免了做法1的睡眠—轮询带来的资源消耗和延迟。</p><h2 id="6-2-线程池的类继承体系"><a href="#6-2-线程池的类继承体系" class="headerlink" title="6.2 线程池的类继承体系"></a>6.2 线程池的类继承体系</h2><p>两个核心类：ThreadPoolExecutor 和 ScheduledThreadPoolExecutor，后者不仅可以执行某个任务，还可以周期性地执行任务。<br>向线程池中提交的每个任务，都必须实现 Runnable 接口，通过最上面的 Executor 接口中的 execute(Runnable command) 向线程池提交任务。<br>在 ExecutorService 中，定义了线程池的关闭接口 shutdown()，还定义了可以返回值的任务，也就是 Callable。</p><h2 id="6-3-ThreadPoolExecutor"><a href="#6-3-ThreadPoolExecutor" class="headerlink" title="6.3 ThreadPoolExecutor"></a>6.3 ThreadPoolExecutor</h2><h3 id="6-3-1-核心数据结构"><a href="#6-3-1-核心数据结构" class="headerlink" title="6.3.1 核心数据结构"></a>6.3.1 核心数据结构</h3><p>每一个线程是一个 Worker 对象。Worder 是 ThreadPoolExecutor 的内部类。Worder 继承于 AQS，也就是 Worker 本身就是一把锁。</p><h3 id="6-3-2-核心配置参数解释"><a href="#6-3-2-核心配置参数解释" class="headerlink" title="6.3.2 核心配置参数解释"></a>6.3.2 核心配置参数解释</h3><ol><li>corePoolSize：在线程池始终维护的线程个数。</li><li>maxPoolSize：在 corePoolSize 已满、队列也满的情况下，扩充至此值。</li><li>keepAliveTime/TimeUnit：maxPoolSize 中的空闲线程，销毁所需要的时间，总线程数收缩回 corePoolSize。</li><li>blockingQueue：线程池所用的队列类型。</li><li>threadFactory：线程创建工厂，可以自定义，也可以默认。</li><li>RejectedExecutionHandler：corePoolSize 已满，队列已满，maxPoolSize 已满，最后的拒绝策略。</li></ol><ul><li></li></ul><p>6个配置参数的处理流程：<br>Step1：判断当前线程数是否大于或等于 coolPoolSize。如果小于，则新建线程执行；如果大于，则进入 Step2。<br>Step2：判断队列是否已满。如未满，则放入；如已满，则进入 step3。<br>Step3：判断当前线程数是否大于或等于 maxPoolSize。如果小于，则新建线程执行；如果大于，则进入 step4。<br>Step4：根据拒绝策略，拒绝任务<br>总结：首先判断 corePoolSize，其次判断 blockingQueue 是否已满，接着判断 maxPoolSize，最后使用拒绝策略。基于这种流程，如果队列是无界的，将永远没有机会走到 step3，也即 maxPoolSize 没有使用，也一定不会走到 step4。</p><h3 id="6-3-3-线程池的优雅关闭"><a href="#6-3-3-线程池的优雅关闭" class="headerlink" title="6.3.3 线程池的优雅关闭"></a>6.3.3 线程池的优雅关闭</h3><ol><li>线程池的生命周期</li></ol><p>线程池有两个关闭函数，shutdown() 和 shutdownNow()，这两个函数会让线程池切换到不同的状态。在队列为空，线程池也为空之后，进入 TIDYING 状态；最后执行一个钩子函数 terminated()，进入 TERMINATED 状态，线程池才“寿终正寝”。状态前移只会从小的状态值往大的状态值迁移，不会逆向迁移。</p><ol start="2"><li>正确关闭线程池的步骤</li></ol><p>在调用 shutdown() 和 shutdownNow() 之后，线程池并不会立即关闭，接下来需要调用 awaitTermination() 来等待线程池关闭。awaitTermination(..) 不断循环判断线程池是否到达了最终状态 TERMINATED，如果是，就返回；如果不是，则通过 termination 条件变量阻塞一段时间，“苏醒”之后，继续判断。</p><ol start="3"><li><p>shutdown() 与 shutdownNow() 的区别</p><ol><li>前者不会清空任务队列，会等所有任务执行完成，后者再清空任务队列。</li><li>前者只会中断空闲的线程，后者会中断所有线程。<h3 id="6-3-4-任务的提交过程分析"><a href="#6-3-4-任务的提交过程分析" class="headerlink" title="6.3.4 任务的提交过程分析"></a>6.3.4 任务的提交过程分析</h3><h3 id="6-3-5-任务的执行过程分析"><a href="#6-3-5-任务的执行过程分析" class="headerlink" title="6.3.5 任务的执行过程分析"></a>6.3.5 任务的执行过程分析</h3>场景1：当调用 shutdown() 的时候，所有线程都处于空闲状态。<br>这意味着任务队列一定是空的。此时，所有线程都会阻塞在 getTask() 函数的地方。然后，所有线程都会收到 interruptIdleWorkers() 发来的中断信号，getTask()  返回 null，所有 Worker 都会退出 while 循环，之后执行 processWorkerExit。<br>场景2：当调用 shutdown() 的时候，所有线程都处于忙碌状态。<br>此时，队列可能是空的，可能是非空的。interruptIdleWorkers() 内部的 tryLock 调用失败，什么都不会做，所有线程会继续执行自己当前的任务。之后所有线程会执行完队列中的任务，直到队列为空，getTask() 才会返回 null。之后，和场景1一样，退出 while 循环。<br>场景3：当调用 shutdown() 的时候，部分线程忙碌，部分线程空闲。<br>有部分线程空闲，说明队列一定是空的，这些线程肯定阻塞在 getTask() 函数的地方。空闲的这些线程会和场景1一样处理，不空闲的线程会和场景2一样处理。<h3 id="6-3-6-线程池的4种拒绝策略"><a href="#6-3-6-线程池的4种拒绝策略" class="headerlink" title="6.3.6 线程池的4种拒绝策略"></a>6.3.6 线程池的4种拒绝策略</h3></li></ol></li><li><p>让调用者直接在自己的线程里面执行，线程池不做处理。</p></li><li><p>线程池直接抛出异常。</p></li><li><p>线程池直接把任务丢掉，当作什么也没有发生。</p></li><li><p>把队列里面最老的任务删除掉，把该任务放入队列中。</p><h2 id="6-4-Callable-与-Future"><a href="#6-4-Callable-与-Future" class="headerlink" title="6.4 Callable 与 Future"></a>6.4 Callable 与 Future</h2><h2 id="6-5-ScheduledThreadPoolExecutor"><a href="#6-5-ScheduledThreadPoolExecutor" class="headerlink" title="6.5 ScheduledThreadPoolExecutor"></a>6.5 ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor 实现了按时间调度来执行任务，两方面：</p></li><li><p>延迟执行任务：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ScheduledFuture &lt;?&gt; schedule(Runable command, long delay, TimeUnit unit);public &lt;V&gt;ScheduledFuture &lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>周期执行任务：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ScheduledFuture &lt;?&gt; scheduleAtFixedRate(Runable command, long initalDelay, TimeUnit unit);public &lt;V&gt;ScheduledFuture &lt;V&gt; schedulWithFixedRate(Runable command, long initalDelay, long delay, TimeUnit unit);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>两个函数的区别：</p></li></ol><ul><li>AtFixedRate：按固定频率执行，与任务本身执行时间无关。但有个前提条件，任务执行时间必须小于间隔时间。</li><li>WithFixedDelay：按固定间隔执行，与任务本身执行时间有关。<h3 id="6-5-1-延迟执行和周期性执行的原理"><a href="#6-5-1-延迟执行和周期性执行的原理" class="headerlink" title="6.5.1 延迟执行和周期性执行的原理"></a>6.5.1 延迟执行和周期性执行的原理</h3><h3 id="6-5-2-延迟执行"><a href="#6-5-2-延迟执行" class="headerlink" title="6.5.2 延迟执行"></a>6.5.2 延迟执行</h3>传进去的是一个 Runnable，外加延迟时间 delay。<h3 id="6-5-3-周期性执行"><a href="#6-5-3-周期性执行" class="headerlink" title="6.5.3 周期性执行"></a>6.5.3 周期性执行</h3>包装一个 ScheduledFutureTask 对象，只是在延迟时间参差之外多了一个周期参数，然后放入 DelayedWorkerQueue 就结束了。</li></ul><p>withFixedRate 和 atFixedRate 的区别体现在 setNextRunTime 里面。</p><ul><li>如果是 atFixedRate，period &gt; 0，下一次开始执行时间等于上一次开始执行时间 + period；</li><li>如果是 withFixedRate，period &lt; 0，下一次开始执行时间等于 triggerTime(-p)，为 now + (-period)，now 即是上一次执行的结束时间。<h2 id="6-6-Executors-工具类"><a href="#6-6-Executors-工具类" class="headerlink" title="6.6 Executors 工具类"></a>6.6 Executors 工具类</h2><h1 id="第七章-ForkJoinPool"><a href="#第七章-ForkJoinPool" class="headerlink" title="第七章 ForkJoinPool"></a>第七章 ForkJoinPool</h1><h2 id="7-1-ForkJoinPool-用法"><a href="#7-1-ForkJoinPool-用法" class="headerlink" title="7.1 ForkJoinPool 用法"></a>7.1 ForkJoinPool 用法</h2>例1：快排<br>第一步：利用数组的第一个元素把数组划分成两半，左边数组里面的元素小于或等于该元素，右边数组里面的元素比该元素大；<br>第二步：对左右的2个子数组分别排序。<h2 id="7-2-核心数据结构"><a href="#7-2-核心数据结构" class="headerlink" title="7.2 核心数据结构"></a>7.2 核心数据结构</h2><h2 id="7-3-工作窃取队列"><a href="#7-3-工作窃取队列" class="headerlink" title="7.3 工作窃取队列"></a>7.3 工作窃取队列</h2>窃取算法是指一个 Worker 线程在执行完毕自己队列中的任务之后，可以窃取其他线程队列中的任务来执行，从而实现负载均衡，以防有的线程很空闲，有的线程很忙。这个过程要用到工作窃取队列。<br>这个队列只有三个操作：</li></ul><ol><li>Worker 线程自己，在队列头部，通过对 queueTop 指针执行加、减操作，实现入队或出队，这是单线程的；</li><li>其他 Worker 线程，在队列尾部，通过对 queueBase 进行累加，实现出队操作，也就是窃取，这是多线程的，需要通过 CAS 操作。</li></ol><p>关键点：</p><ol><li><p>整个队列是环形的，也就是一个数组实现的 RingBuffer。并且 queueBase 会一直累加，不会减少；queueTop 会累加、减小。最后，queueBase、queueTop 的值都会大于整个数组的长度，只是计算数组的下标的时候，会取 queueTop &amp; (queue.length-1)，queueBase &amp; (queue.length-1)。因为 queue.length 是2的整数次方，这里也就是对 queue.length 是2的整数次方，这里也是对 queue.length 进行取模操作。</p><ol><li>当 queueTop - queueBase = queue.length-1 的时候，队列为满，此时需要扩容；</li><li>当 queueTop = queueBase 的时候，队列为空，Worker 线程即将进入阻塞状态</li></ol></li><li><p>当队列满了之后会扩容，所以被称为是动态的。</p><h2 id="7-4-ForkJoinPool-状态控制"><a href="#7-4-ForkJoinPool-状态控制" class="headerlink" title="7.4 ForkJoinPool 状态控制"></a>7.4 ForkJoinPool 状态控制</h2><h3 id="7-4-1-状态变量-ctl-解析"><a href="#7-4-1-状态变量-ctl-解析" class="headerlink" title="7.4.1 状态变量 ctl 解析"></a>7.4.1 状态变量 ctl 解析</h3><p>ctl 变量的64比特位被分为五部分：<br>AC：最高的16个比特位，表示 Active 线程数 -parallelism，parallelism 是上面的构造函数传进去的参数；<br>TC：次高的16个比特位，表示 Total 线程数 -parallelism；<br>ST：1个比特位，如果是1，表示整个 ForkJoinPool 正在关闭；<br>EC：15个比特位，表示阻塞栈的栈顶线程的 wait count；<br>ID：16个比特位，表示阻塞栈的栈顶线程对应的 poolIndex。</p><h3 id="7-4-2-阻塞栈-Treiber-Stack"><a href="#7-4-2-阻塞栈-Treiber-Stack" class="headerlink" title="7.4.2 阻塞栈 Treiber Stack"></a>7.4.2 阻塞栈 Treiber Stack</h3><p>要实现多个线程的阻塞、唤醒，除了 park/unpark 这一对操作原语，还需要一个无锁链表实现的阻塞队列，把所有阻塞的线程串在一起。<br>在 ForkJoinPool 中，没有使用阻塞队列，而是使用了阻塞栈。把所有空闲的 Worker 线程放在一个栈里面，这个栈同样通过链来实现，名为 Treiber Stack。<br>首先，ForkJoinWorkerThread 有一个 poolIndex 变量，记录了自己在 ForkJoinWorkerThread[] 数组中的下标位置，poolIndex 变量就相当于每个 ForkJoinPoolWorkerThread 对象的地址；其次 ForkJoinWorkerThread 还有一个 nextWait 变量，记录了前一个阻塞线程的 poolIndex，这个 nextWait 变量就相当于链表的 next 指针，把所有的阻塞线程串联在一起，组成一个Treiber Stack。<br>最后，ctl 变量的最低16位，记录了栈的栈顶线程的 poolIndex；中间的15位，记录了栈顶的线程被阻塞的次数，也称为 wait count。</p><h3 id="7-4-3-ctl-变量的初始值"><a href="#7-4-3-ctl-变量的初始值" class="headerlink" title="7.4.3 ctl 变量的初始值"></a>7.4.3 ctl 变量的初始值</h3><p>因为在初始的时候，ForkJoinPool 中的线程个数为0，所以 AC = 0 - parallelism，TC = 0 - parallelism。这意味着只有高32位的AC、TC 两个部分填充了值，低32位都是0填充。</p><h3 id="7-4-4-ForkJoinWorkerThread-状态与个数分析"><a href="#7-4-4-ForkJoinWorkerThread-状态与个数分析" class="headerlink" title="7.4.4 ForkJoinWorkerThread 状态与个数分析"></a>7.4.4 ForkJoinWorkerThread 状态与个数分析</h3><p>ForkJoinPool 中的线程可能的状态有三种：</p></li><li><p>空闲状态（放在Treiber Stack里面）</p></li><li><p>活跃状态（正在执行某个 ForkJoinTask，未阻塞）</p></li><li><p>阻塞状态（正在执行某个 ForkJoinTask，但阻塞了，于是调用 join，等待另外一个任务的结果返回）</p></li></ol><p>ctl更好地反映出了三种状态：<br>高32位：u = (int)(ctl&gt;&gt;&gt;32)，然后 u 又拆分成 tc、ac 两个16位；<br>低32位：e = (int)ctl</p><ol><li>e&gt;0，说明 Treiber Stack 不为空，有空闲线程；e = 0，说明没有空闲线程；</li><li>ac&gt;0，说明有活跃线程；ac &lt;= 0，说明没有空闲线程，并且还未超出 parallelism；</li><li>tc&gt;0，说明总线程数 &gt; parallelism。</li></ol><p>tc 与 ac 的差值，也就是总线程数与活跃线程数的差异，在 ForkJoinPool 中有另外一个变量 blockedCount 记录。<br>所以，通过 crl 和 blockedCount 这两个变量，可以知道在整个 ForkJoinPool 中所有空闲线程、活跃线程以及阻塞线程的数量。</p><h2 id="7-5-Worker-线程的阻塞-唤醒"><a href="#7-5-Worker-线程的阻塞-唤醒" class="headerlink" title="7.5 Worker 线程的阻塞-唤醒"></a>7.5 Worker 线程的阻塞-唤醒</h2><h3 id="7-5-1-阻塞-入栈"><a href="#7-5-1-阻塞-入栈" class="headerlink" title="7.5.1 阻塞-入栈"></a>7.5.1 阻塞-入栈</h3><p>函数的第一个参数就是要阻塞的线程，第二个参数是当前的 ctl 变量的值。入栈，也就是3步：<br>第一步：w.nextWait = (int)c，即使 w.nextWait 指针，指向栈顶；<br>第二步：long nc = (long)(v &amp; E_MASK) | (c - AC_UNIT) &amp; (AC_MASK|TC_MASK))，即新的栈顶就是当前的线程w，同时把 ac 的值减1，即活跃线程数减1；<br>第三步：将 nc 通过 CAS 赋值给 ctl 变量 UNSAFE。compareAndSwapLong(this, ctlOffset, c, nc)。<br>此时入栈成功，ctl 变量更新成功。最后，调用 LockSupport.park(this) 阻塞自己。但是在这期间做了很多其他事情：</p><ol><li>统计 stealCount。</li><li>判断 ForkJoinPool 是否关闭，以及是否所有线程都处于空闲状态，整个 ForkJoinPool 是否处于静默状态</li><li>在阻塞之前，为了保险，又重新扫描了一遍队列，观察是否有任务可以执行。</li></ol><h3 id="7-5-2-唤醒-出栈"><a href="#7-5-2-唤醒-出栈" class="headerlink" title="7.5.2 唤醒-出栈"></a>7.5.2 唤醒-出栈</h3><p>当 signalWorker 函数的参数为空，它会唤醒栈顶的线程，如：e &gt; 0，说明栈不为空，此时 e 的最低16位，存储的是栈顶线程的poolIndex，取出来唤醒；e = 0，说明栈为空，此时开一个新线程。</p><h2 id="7-6-任务的提交过程分析"><a href="#7-6-任务的提交过程分析" class="headerlink" title="7.6 任务的提交过程分析"></a>7.6 任务的提交过程分析</h2><p>如何区分一个任务是内部任务还是外部任务？<br>可以通过调用该函数的线程类型判断。如果线程类型是 ForkJoinWorkerThread，说明是线程池内部的某个线程在调用该函数，则把该任务放入该线程的局部队列；否则，是外部线程在调用该函数，则将该任务加入全局队列。</p><h3 id="7-6-1-内部提交任务-pushTask"><a href="#7-6-1-内部提交任务-pushTask" class="headerlink" title="7.6.1 内部提交任务 pushTask"></a>7.6.1 内部提交任务 pushTask</h3><p>由于工作窃取队列的特性，其对 queueTop 的操作是单线程的，所以此处不需要执行 CAS 操作。当 queueTop - queueBase = 0 的时候，队列为空，此处为了保险，写作 queueTop - queueBase &lt;= 2，不影响正确性。</p><h3 id="7-6-2-外部提交任务-addSubmission"><a href="#7-6-2-外部提交任务-addSubmission" class="headerlink" title="7.6.2 外部提交任务 addSubmission"></a>7.6.2 外部提交任务 addSubmission</h3><p>外部多个线程会调用该函数，所以要加锁，入队列和扩容的逻辑和线程内部的队列基本相同，最后，调用 signalWork()，通知一个空闲线程来取。</p><h2 id="7-7-工作窃取算法：任务的执行过程分析"><a href="#7-7-工作窃取算法：任务的执行过程分析" class="headerlink" title="7.7 工作窃取算法：任务的执行过程分析"></a>7.7 工作窃取算法：任务的执行过程分析</h2><h3 id="7-7-1-顺序锁-SeqLock"><a href="#7-7-1-顺序锁-SeqLock" class="headerlink" title="7.7.1 顺序锁 SeqLock"></a>7.7.1 顺序锁 SeqLock</h3><ol><li>读线程在读取共享数据之前先读取 sequence number，在读取数据之后仔读一次 sequence number，如果两次的值不同，说明在此期间有其他线程修改了数据，此次读取数据无效重新读取；</li><li>写线程，在写入数据之前，累加一次 sequence number，在写入数据之后，再累加一次 sequence number。</li></ol><p>最初，sequence number = 0，读线程不会修改 sequence number，而一个写线程会累加两次 sequence number，所以 sequence number 始终是偶数。如果 sequence number 是奇数，说明当前某个写线程正在修改数据，其他写线程被互斥。<br>对于写线程而言，发现 sequence number 是奇数，就不能修改共享数据了。对于读线程而言，发现 sequence number 是奇数，也不能再读取数据；如果发现 sequence number 是偶数，那么在读取数据前后分别读取一次 sequence number，如果两次的值相同，则读取成功，否则重新读取。</p><h3 id="7-7-2-scanGuard-解析"><a href="#7-7-2-scanGuard-解析" class="headerlink" title="7.7.2 scanGuard 解析"></a>7.7.2 scanGuard 解析</h3><p>scanGuard 变量充当了顺序锁的 sequence number 的功能，共享数据就是 Worker 线程数组 ws。所以，在scan 函数中，在函数开始的时候，读取了一次 scanGuard，扫描完 ws 对应的队列，又读取了一次 scanGuard，发现两次的值不同。说明在这期间 ws 的数组发生了变化，可能是新加了线程，ws 数组扩容了，于是返回false，重新进入 scan 函数。</p><h2 id="7-8-ForkJoinTask-的-fork-join"><a href="#7-8-ForkJoinTask-的-fork-join" class="headerlink" title="7.8 ForkJoinTask 的 fork/join"></a>7.8 ForkJoinTask 的 fork/join</h2><h3 id="7-8-1-fork"><a href="#7-8-1-fork" class="headerlink" title="7.8.1 fork"></a>7.8.1 fork</h3><h3 id="7-8-2-join-的层层嵌套"><a href="#7-8-2-join-的层层嵌套" class="headerlink" title="7.8.2 join 的层层嵌套"></a>7.8.2 join 的层层嵌套</h3><h2 id="7-9-ForkJoinPool-的优雅关闭"><a href="#7-9-ForkJoinPool-的优雅关闭" class="headerlink" title="7.9 ForkJoinPool 的优雅关闭"></a>7.9 ForkJoinPool 的优雅关闭</h2><h3 id="7-9-1-关键的-terminate-变量"><a href="#7-9-1-关键的-terminate-变量" class="headerlink" title="7.9.1 关键的 terminate 变量"></a>7.9.1 关键的 terminate 变量</h3><h3 id="7-9-2-shutdown-与-shutdownNow-的区别"><a href="#7-9-2-shutdown-与-shutdownNow-的区别" class="headerlink" title="7.9.2 shutdown() 与 shutdownNow() 的区别"></a>7.9.2 shutdown() 与 shutdownNow() 的区别</h3><p>shutdown() 只拒绝新提交的任务； shutdownNow() 会取消现有的全局队列和局部队列中的任务，同时唤醒所有空闲的线程，让这些线程自动退出。</p><h1 id="第八章-CompletableFuture"><a href="#第八章-CompletableFuture" class="headerlink" title="第八章 CompletableFuture"></a>第八章 CompletableFuture</h1><h2 id="8-1-CompletableFuture-用法"><a href="#8-1-CompletableFuture-用法" class="headerlink" title="8.1 CompletableFuture 用法"></a>8.1 CompletableFuture 用法</h2><h3 id="8-1-1-最简单的用法"><a href="#8-1-1-最简单的用法" class="headerlink" title="8.1.1 最简单的用法"></a>8.1.1 最简单的用法</h3><p>CompletableFuture 实现了 Future 接口，所以它也具有 Future 的特性：调用 get() 方法会阻塞在那，知道结果返回。</p><h3 id="8-1-2-提交任务：runAsync-与-supplyAsync"><a href="#8-1-2-提交任务：runAsync-与-supplyAsync" class="headerlink" title="8.1.2 提交任务：runAsync 与 supplyAsync"></a>8.1.2 提交任务：runAsync 与 supplyAsync</h3><p>CompletableFuture 和 Future 很相似，都可以提交两类任务：一类是无返回值的，另一类是有返回值的。</p><h3 id="8-1-3-链式的-CompletableFuture：thenRun、thenAccept-和-thenApply"><a href="#8-1-3-链式的-CompletableFuture：thenRun、thenAccept-和-thenApply" class="headerlink" title="8.1.3 链式的 CompletableFuture：thenRun、thenAccept 和 thenApply"></a>8.1.3 链式的 CompletableFuture：thenRun、thenAccept 和 thenApply</h3><p>对于 Future，在提交任务之后，只能调用 get() 等结果返回；但对于CompletableFuture，可以在结果上面加一个 callback，当得到结果之后，再接着执行 callback。<br>最后紧急执行 callback 的区别：</p><ol><li><p>thenRun 后面跟的是一个无参数、无返回值的方法，即 Runnable，所以最终的返回值是 CompletableFuture<void> 类型。</void></p></li><li><p>thenAccept 后main跟的是一个有参数、无返回值的方法，称为 Consumer，返回值也是CompletableFuture<void> 类型。顾名思义，只进不出，所以称为 Consumer；前面的 Supplier，是无参数，有返回值，只出不进，和 Consumer 刚好相反。</void></p></li><li><p>thenApply 后面跟的是一个有参数、有返回值的方法，称为 Function。返回值是 CompletableFuture<string> 类型。</string></p><h3 id="8-1-4-CompletableFuture-的组合：thenCompose-与-thenCombine"><a href="#8-1-4-CompletableFuture-的组合：thenCompose-与-thenCombine" class="headerlink" title="8.1.4 CompletableFuture 的组合：thenCompose 与 thenCombine"></a>8.1.4 CompletableFuture 的组合：thenCompose 与 thenCombine</h3><h3 id="8-1-5-任意个-CompletableFuture-的组合"><a href="#8-1-5-任意个-CompletableFuture-的组合" class="headerlink" title="8.1.5 任意个 CompletableFuture 的组合"></a>8.1.5 任意个 CompletableFuture 的组合</h3><p>thenCompose 与 thenCombine 只能组合2个 CompletableFuture，而 allof 和anyof 可以组合任意多个 CompletableFuture。这个两个函数都是静态函数，参数是变长的 CompletableFuture 的集合，allof 是与，anyof 是或</p><h2 id="8-2-四种任务原型"><a href="#8-2-四种任务原型" class="headerlink" title="8.2 四种任务原型"></a>8.2 四种任务原型</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1628527881616-ac2df675-70dd-4fc3-99c2-c544628b8532.png#align=left&amp;display=inline&amp;height=158&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=316&amp;originWidth=2054&amp;size=68706&amp;status=done&amp;style=none&amp;width=1027" alt="image.png"><br>runAsync 与 supplierAsync 是 CompletableFuture 的静态方法；而 thenAccept、runAsync、thenApply 是 CompletableFuture 的成员方法。<br>因为初始的时候没有 CompletableFuture 对象，也没有参数可传，所以提交的只能是 Runnable 或者 Supplier，只能是静态方法；<br>通过静态方法生成 CompletableFuture 对象之后，便可以链式地提交其他任务了，这个时候就可以提交 Runnable、Consumer、Function，且都是成员方法。</p><h2 id="8-3-CompletionFuture-接口"><a href="#8-3-CompletionFuture-接口" class="headerlink" title="8.3 CompletionFuture 接口"></a>8.3 CompletionFuture 接口</h2><h2 id="8-4-CompletableFuture-内部原理"><a href="#8-4-CompletableFuture-内部原理" class="headerlink" title="8.4 CompletableFuture 内部原理"></a>8.4 CompletableFuture 内部原理</h2><h3 id="8-4-1-CompletableFuture-的构造：ForkJoinPool"><a href="#8-4-1-CompletableFuture-的构造：ForkJoinPool" class="headerlink" title="8.4.1 CompletableFuture 的构造：ForkJoinPool"></a>8.4.1 CompletableFuture 的构造：ForkJoinPool</h3><p>asyncPool 是一个 static类型，supplierAsync、asyncSupplyStage 都是 static 函数。Static 函数返回一个 CompletableFuture 类型对象，之后可以链式调用，CompletionStage 里面的各个方法。</p><h3 id="8-4-2-任务类型的适配"><a href="#8-4-2-任务类型的适配" class="headerlink" title="8.4.2 任务类型的适配"></a>8.4.2 任务类型的适配</h3><h3 id="8-4-3-任务的链式执行过程分析"><a href="#8-4-3-任务的链式执行过程分析" class="headerlink" title="8.4.3 任务的链式执行过程分析"></a>8.4.3 任务的链式执行过程分析</h3><p>AsyncSupply 三个关键点：</p></li><li><p>继承自 ForkJoinTask，所以能够提交ForkJoinPool 来执行</p></li><li><p>封装了 Supplier f，即它所执行任务的具体内容</p></li><li><p>该任务的返回值，即 CompletableFuture d，也被封装在里面。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://quricolouis.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://quricolouis.github.io/tags/Java/"/>
    
    <category term="JDK源码" scheme="http://quricolouis.github.io/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
    <category term="读书笔记" scheme="http://quricolouis.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
