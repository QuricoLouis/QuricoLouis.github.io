<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java并发实现原理「JDK源码剖析」, QuricoLouis 软件工程 java后端开发 太原理工大学">
    <meta name="description" content="本科 | 软件工程 | java后端开发">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="baidu-site-verification" content="code-THscGEvLSO" />
    <meta name="google-site-verification" content="BbagwFAOx3eqpYQTN02O2Vw70b_ZYSN-VORxC3BoLfo" />
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java并发实现原理「JDK源码剖析」 | QuricoLouis</title>

    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/QuricoLouis/imgBed/blog/20210731104423.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;900&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?aaa6c944b0ed07922901d7fc571a171d";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="QuricoLouis" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
<!--                    -->
<!--                    <img src="https://cdn.jsdelivr.net/gh/QuricoLouis/imgBed/blog/20210731104423.png" class="logo-img" alt="LOGO">-->
<!--                    -->
                    <span class="logo-span">QuricoLouis</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/archives">
          
          <i class="fas fa-paper-plane" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>时轴</span>
        </a>
      </li>
      
      <li>
        <a href="/categories">
          
          <i class="fas fa-bookmark" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>分类</span>
        </a>
      </li>
      
      <li>
        <a href="/tags">
          
          <i class="fas fa-tag" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>标签</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-heartbeat" style="zoom: 0.6;"></i>
      
      <span>清单</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/List/music">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>音乐</span>
        </a>
      </li>
      
      <li>
        <a href="/List/galleries">
          
          <i class="fas fa-image" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>相册</span>
        </a>
      </li>
      
      <li>
        <a href="/List/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>视频</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-envelope" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tools" class="waves-effect waves-light">
      
      <i class="fas fa-suitcase" style="zoom: 0.6;"></i>
      
      <span>百宝箱</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-link" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/QuricoLouis/imgBed/blog/20210731104423.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">QuricoLouis</div>
        <div class="logo-desc">
            
            本科 | 软件工程 | java后端开发
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-archive"></i>
			
			归档
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/archives " style="margin-left:75px">
				  
				   <i class="fa fas fa-paper-plane" style="position: absolute;left:50px" ></i>
			      
		          <span>时轴</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories " style="margin-left:75px">
				  
				   <i class="fa fas fa-bookmark" style="position: absolute;left:50px" ></i>
			      
		          <span>分类</span>
                  </a>
                </li>
              
                <li>

                  <a href="/tags " style="margin-left:75px">
				  
				   <i class="fa fas fa-tag" style="position: absolute;left:50px" ></i>
			      
		          <span>标签</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-heartbeat"></i>
			
			清单
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/List/music " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>音乐</span>
                  </a>
                </li>
              
                <li>

                  <a href="/List/galleries " style="margin-left:75px">
				  
				   <i class="fa fas fa-image" style="position: absolute;left:50px" ></i>
			      
		          <span>相册</span>
                  </a>
                </li>
              
                <li>

                  <a href="/List/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>视频</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-envelope"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tools" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-suitcase"></i>
			
			百宝箱
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-link"></i>
			
			友链
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/QuricoLouis/" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/QuricoLouis/" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200928015642.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java并发实现原理「JDK源码剖析」</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        background-color: white;
        width: 345px;
        padding-left: 20px;
        border-radius: 10px;
        box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }
    
    #toc-content {
        height: calc(100vh - 300px);
        overflow: scroll;

    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
        bottom: 120px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                            <a href="/tags/JDK%E6%BA%90%E7%A0%81/">
                                <span class="chip bg-color">JDK源码</span>
                            </a>
                        
                            <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
                                <span class="chip bg-color">读书笔记</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">
                                读书笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-08-27
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-09-06
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    17.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    66 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="第一章-多线程基础"><a href="#第一章-多线程基础" class="headerlink" title="第一章  多线程基础"></a>第一章  多线程基础</h1><h2 id="1-1-线程关闭"><a href="#1-1-线程关闭" class="headerlink" title="1.1  线程关闭"></a>1.1  线程关闭</h2><h3 id="1-1-1-stop-与-destory-函数"><a href="#1-1-1-stop-与-destory-函数" class="headerlink" title="1.1.1  stop() 与 destory() 函数"></a>1.1.1  stop() 与 destory() 函数</h3><p>问：运行一半的线程能否强制杀死？<br>答：在Java中，stop()、destory()之类的函数官方明确不建议使用，如果强制杀死线程，则线程中所用的资源，例&nbsp; 如文件描述符、网络连接等不能正常关闭。<br>一个线程一旦运行起，就不要去强行打断它，合理的关闭方法是让其运行完（也就是函数执行完毕），干净地&nbsp; 释放掉所有的资源，然后推出。如果是一个不断循环运行的线程，就需要用到线程间的通信机制，让主线程通知其退出。</p>
<h3 id="1-1-2-守护线程"><a href="#1-1-2-守护线程" class="headerlink" title="1.1.2 守护线程"></a>1.1.2 守护线程</h3><p>当在一个JVM进程里开多个线程时，这些线程被分成两类：<strong>守护线程</strong>和<strong>非守护线程</strong>。默认开的是<strong>非守护线程</strong>。<br>当所有的非守护线程推出后，整个JVM进程就会退出。意思就是守护线程“不算数”，守护线程不影响整个JVM进程的退出。例如：<strong>垃圾回收线程就是守护线程</strong>，它们在后台默默工作，当开发者的所有前台线程(非守护线程)都退出之后，整个JVM进程就退出了。</p>
<h2 id="1-2-interruptedException-函数与-interrupt-函数"><a href="#1-2-interruptedException-函数与-interrupt-函数" class="headerlink" title="1.2  interruptedException() 函数与 interrupt() 函数"></a>1.2  interruptedException() 函数与 interrupt() 函数</h2><h3 id="1-2-1-什么情况下会抛出-interrupted-异常"><a href="#1-2-1-什么情况下会抛出-interrupted-异常" class="headerlink" title="1.2.1  什么情况下会抛出 interrupted 异常"></a>1.2.1  什么情况下会抛出 interrupted 异常</h3><p>只有声明了会抛出 InterruptedException 的函数才会抛出异常<br>例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public static native void sleep(long millis) throws InterruptedException{...}
public final void wait() throws InterruptedException{...}
public final void join() throws InterruptedException{...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="1-2-2-轻量级阻塞与重量级阻塞"><a href="#1-2-2-轻量级阻塞与重量级阻塞" class="headerlink" title="1.2.2  轻量级阻塞与重量级阻塞"></a>1.2.2  轻量级阻塞与重量级阻塞</h3><p><strong>轻量级阻塞：</strong>能够被中断的阻塞。对应的线程状态是 WAITING 或者 TIMED_WAITING。<br><strong>重量级阻塞：</strong>像 synchronized 这种不能被中断的阻塞。对应的状态 BLOCKED。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627270281876-93f83d61-a06c-46f0-9932-1342a86b977c.png#align=left&amp;display=inline&amp;height=183&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=366&amp;originWidth=715&amp;size=121601&amp;status=done&amp;style=none&amp;width=357.5" alt="image.png"><br>图1-1  线程的状态迁移过程</p>
<h3 id="1-2-3-t-isInterrupted-与-Thread-interrupted"><a href="#1-2-3-t-isInterrupted-与-Thread-interrupted" class="headerlink" title="1.2.3  t.isInterrupted() 与 Thread.interrupted()"></a>1.2.3  t.isInterrupted() 与 Thread.interrupted()</h3><p>t.interrupted() 相当于给线程发送了一个唤醒的信号,果线程此时恰好处于 waiting 或者  timed_waiting 状态，        就会抛出一个InterruptedException，并且线程被唤醒。而如果线程此时并没有被阻塞，则线程什么都不会做。但在后续，线程可以判断自己是否收到过其他线程发来的中断信号，然后做一些对应的处理。<br><strong>前者是静态函数，后者是非静态函数，两者之间的区别在于前者只是读取中断状态，不做修改状态；后者不仅读取中断状态，还会重置中断标志位。</strong>    </p>
<h2 id="1-3-synchronized-关键字"><a href="#1-3-synchronized-关键字" class="headerlink" title="1.3  synchronized 关键字"></a>1.3  synchronized 关键字</h2><h3 id="1-3-1-锁的对象是什么"><a href="#1-3-1-锁的对象是什么" class="headerlink" title="1.3.1  锁的对象是什么"></a>1.3.1  锁的对象是什么</h3><p>synchronized关键字的意思是给某个对象加了把锁</p>
<ul>
<li>对于非静态成员函数，锁其实是家在 a 对象上面的；</li>
<li>对于静态成员函数，锁是加在 A.class 上面的</li>
</ul>
<p><strong>一个静态成员函数和一个非静态成员函数，都加了synchronized关键字，分别被两个线程调用，它们是否互斥？</strong><br><strong>答：因为是两把不同的锁，所以不会互斥</strong></p>
<h3 id="1-3-2-锁的本质是什么"><a href="#1-3-2-锁的本质是什么" class="headerlink" title="1.3.2  锁的本质是什么"></a>1.3.2  锁的本质是什么</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627296855136-6b6218ef-254e-4981-bcab-5ce178231f2b.png#align=left&amp;display=inline&amp;height=113&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=225&amp;originWidth=753&amp;size=42435&amp;status=done&amp;style=none&amp;width=376.5" alt="image.png"><br>图 1-2 线程、锁和资源关系图<br>多个线程要访问同一个资源。线程就是一段段运行的代码；资源就是一个变量、一个对象或一个文件等；而锁就是要实现线程对资源的访问控制，保证同一时间只能有一个线程去访问某一个资源。<br><strong>从程序角度，锁就是一个“对象”，这个对象要完成的事情：</strong></p>
<ol>
<li>这个对象内部得有一个标志位（state变量），记录自己有没有被某个线程占用。最简单的情况是这个 <strong>state</strong> 有 0、1 两个取值，0 表示没有线程占用这个锁，1 表示有某个线程占用了这个锁</li>
<li>如果这个对象被某个线程占用，它得记录这个线程的 thread ID，知道自己是被哪个线程占用了。</li>
<li>这个对象还得维护一个 thread id list，记录其他所有阻塞的、等待拿这个锁的线程。在当前线程释放锁之后（也就是把state从1改回0），从这个 thread id list 里面取一个线程唤醒。</li>
</ol>
<p><strong>既然锁是一个对象，要访问的共享资源本身也是一个对象，这两个对象可以合成一个对象。</strong><br>资源和锁合二为一，使得在 Java 里面，synchronized 关键字可以加在任何对象的成员上面。这也就意味着，这个对象既是共享资源，同时也具备“锁”的功能。</p>
<h3 id="1-3-3-synchronized-实现原理"><a href="#1-3-3-synchronized-实现原理" class="headerlink" title="1.3.3  synchronized 实现原理"></a>1.3.3  synchronized 实现原理</h3><p>在 Java 的对象头里，有一块数据叫 Mark Word。在64位机器上，Mark Word 是8字节（64位）的，这64位中有2个重要字段：<strong>锁标志位</strong>和**占用锁的 tread ID。 **</p>
<h2 id="1-4-wait-与-notify"><a href="#1-4-wait-与-notify" class="headerlink" title="1.4  wait() 与 notify()"></a>1.4  wait() 与 notify()</h2><h3 id="1-4-1-生产者-消费者模型"><a href="#1-4-1-生产者-消费者模型" class="headerlink" title="1.4.1  生产者-消费者模型"></a>1.4.1  生产者-消费者模型</h3><p><strong>生产者-消费者模型是一个常见的多线程编程模型。</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627296966953-a10ed925-c2cb-461a-a66b-4d4207db1efa.png#align=left&amp;display=inline&amp;height=149&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=298&amp;originWidth=728&amp;size=71188&amp;status=done&amp;style=none&amp;width=364" alt="image.png"></strong><br>图 1-4 生产者-消费者模型<br>一个内存队列，多个生产者线程我那个内存队列放数据；多个消费者线程从内存队列中取数据要实现这样一个编程模型，<strong>需要做下面几件事情：</strong></p>
<ol>
<li>内存队列本身要加锁，才能实现线程安全。</li>
<li>阻塞。当内存队列满了，生产者放不进去时，会被阻塞；当内存队列是空的时候，消费者无事可做，会被阻塞。</li>
<li>双向管理。消费者被阻塞之后，生产者放入新数据，要 notify() 消费者；反之，生产者被阻塞之后，消费者消费了数据，要 notify() 生产者。</li>
</ol>
<p><strong>第 1 件事必须要做，第 2 件事和第 3 件事不一定要做。</strong></p>
<ul>
<li><strong>如何阻塞？</strong></li>
</ul>
<p>办法1：线程自己阻塞自己，也就是生产者、消费者线程各自调用 wait() 和 notify()。<br>办法2：用一个阻塞队列，当取不到或者放不进去数据的时候，入队/出队函数本身就是阻塞的。</p>
<ul>
<li><strong>如何双向通知？</strong></li>
</ul>
<p>办法1：wait() 和 notify() 机制。<br>办法2：Condition机制</p>
<h3 id="1-4-2-为什么必须和-synchronized-一起使用"><a href="#1-4-2-为什么必须和-synchronized-一起使用" class="headerlink" title="1.4.2  为什么必须和 synchronized 一起使用"></a>1.4.2  为什么必须和 synchronized 一起使用</h3><p>开两个线程，线程A调用f1()，线程B调用f2()。两个线程之间要<strong>通信</strong>，对于同一个对象来说，一个线程调用该对象的 wait()，另一个线程调用该对象的 notify()，该对象本身就需要同步！所以，在调用 wait()、notify() 之前，要先通过 synchronized 关键字同步给对象，也就是给该对象加锁。</p>
<h3 id="1-4-3-为什么-wait-的时候必须释放锁"><a href="#1-4-3-为什么-wait-的时候必须释放锁" class="headerlink" title="1.4.3  为什么 wait() 的时候必须释放锁"></a>1.4.3  为什么 wait() 的时候必须释放锁</h3><p>wait()内部伪代码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wait(){
//释放锁
//阻塞，等待被其他线程notify
//重新拿锁
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="1-4-4-wait-与-notify-的问题"><a href="#1-4-4-wait-与-notify-的问题" class="headerlink" title="1.4.4  wait() 与 notify() 的问题"></a>1.4.4  wait() 与 notify() 的问题</h3><p>生产者本来只想通知消费者，但它把其他的生产者也通知了；消费者本来只想通知生产者，但它把其他的消费者也通知了。原因是 wait() 和 notify() 作用的对象和 synchronized 作用的对象是同一个，每个对象没有区分标识。<strong>精确唤醒我们可以用 Condition 来实现。</strong></p>
<h2 id="1-5-volatile-关键字"><a href="#1-5-volatile-关键字" class="headerlink" title="1.5  volatile 关键字"></a>1.5  volatile 关键字</h2><h3 id="volatile三重功效"><a href="#volatile三重功效" class="headerlink" title="volatile三重功效"></a>volatile三重功效</h3><ul>
<li>64位写入的原子性</li>
<li>内存可见性</li>
<li>禁止重排序<h3 id="1-5-1-64位写入的原子性（Half-Write）"><a href="#1-5-1-64位写入的原子性（Half-Write）" class="headerlink" title="1.5.1  64位写入的原子性（Half Write）"></a>1.5.1  64位写入的原子性（Half Write）</h3>多线程场景下，线程 A 调用 set(100)，线程 B 调用 get()，在某些场景下，返回值可能不是 100 。<br>这是因为 JVM 规范没有要求 64 位的 long 或者 double 的写入是原子的。在 32 位的机器上，一个 64 位变量的写入可能被拆分成两个 32 位的写操作来执行。这样一来，读取线程就可能读到<strong>一半的值</strong> 。<br>解决办法也：在 long 前面加上 <strong>volatile</strong> 关键字。<h3 id="1-5-2-内存可见性"><a href="#1-5-2-内存可见性" class="headerlink" title="1.5.2  内存可见性"></a>1.5.2  内存可见性</h3>不仅 64 位，32 位或者位数更小的赋值和取值操作，其实也有问题。比如一个线程修改变量值为 true 之后，另一个线程去读，读到的事 false，但是之后能读到 true。也就是<strong>最终一致性</strong>，不是<strong>强一致性</strong>。<br>所以，<strong>内存可见性</strong>， 指的是<strong>写完之后立即对其他线程可见</strong>，它的反面不是<strong>不可见</strong>，而是<strong>稍后才能看见</strong>。<br>解决这个问题很容易，给变量加上 <strong>volatile</strong> 关键字即可。<h3 id="1-5-3-重排序：DCL问题"><a href="#1-5-3-重排序：DCL问题" class="headerlink" title="1.5.3  重排序：DCL问题"></a>1.5.3  重排序：DCL问题</h3>单例模式的线程安全，常用写法为DCL（Double Checking Locking）<pre class="line-numbers language-java" data-language="java"><code class="language-java">public case Sington { 
  	private static Sington instance;
  	private static Sington getInstance() {
      	if (instance == null) {					// DCL
          	synchronized(Sington.class) {		// 为了性能，延迟使用synchronized
              	if (instance == null)
                  	instance = new Instance();	// 有问题的代码
            }
        }
    }
  	return instance;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
上述的 instance = new Instance() 代码有问题：其底册会分为三个操作：</li>
</ul>
<ol>
<li>分配一块内存</li>
<li>在内存上初始化成员变量</li>
<li>把 instance 引用指向内存。</li>
</ol>
<p><strong>操作2和3可能重排序。</strong>即先把 instance 指向内存，再初始化成员变量，因为二者先后<strong>没有依赖关系</strong>。此时，另一个线程可能拿到一个未完全初始化的对象，直接去访问里面的成员变量，就可能出错。这就是典型的“<strong>构造函数溢出</strong>”问题。<br>解决方法：为 instance 变量加上 <strong>volatile</strong> 修饰。</p>
<h2 id="1-6-JVM与happen-before"><a href="#1-6-JVM与happen-before" class="headerlink" title="1.6  JVM与happen-before"></a>1.6  JVM与happen-before</h2><h3 id="1-6-1-为什么会存在“内存可见性”问题"><a href="#1-6-1-为什么会存在“内存可见性”问题" class="headerlink" title="1.6.1  为什么会存在“内存可见性”问题"></a>1.6.1  为什么会存在“内存可见性”问题</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627375870977-edfcb6bd-061c-4720-bdd8-66a36e55e0a9.png#align=left&amp;display=inline&amp;height=324&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=648&amp;originWidth=1018&amp;size=338606&amp;status=done&amp;style=none&amp;width=509" alt="image.png"><br>图 1-4  加入 Store Buffer 和 Load Buffer 的 CPU 缓存体系<br>L1、L2、L3 和主内存之间是同步的，有缓存一致性协议的保证，但是 Store Buffer、Load Buffer 和 L1之间却是异步的。也就是说，往内存中写入一个变量，这个变量会保存在 Storre Buffer 里面，稍后才会异步地写入 L1 中，同时同步 写入主内存中。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627376276849-d991e1f0-a1d8-4659-9545-e2665dd99ba2.png#align=left&amp;display=inline&amp;height=267&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=534&amp;originWidth=1086&amp;size=270710&amp;status=done&amp;style=none&amp;width=543" alt="image.png"><br>图 1-5  操作系统内核视角下的CPU缓存模型<br>多个 CPU，多个 CPU 多核，每个核上面可能还有多个硬件线程，对于操作系统来讲，就相当于一个个逻辑 CPU。每个逻辑CPU都有自己的缓存，这些缓存和主内存之间不是完全同步的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627376529987-06147cc8-e507-4b54-846a-98478d7e5a37.png#align=left&amp;display=inline&amp;height=268&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=536&amp;originWidth=1086&amp;size=231202&amp;status=done&amp;style=none&amp;width=543" alt="image.png"><br>图 1-6  JVM抽象内存模型<br>对应到 Java 里，就是 JVM 抽象内存模型</p>
<h3 id="1-6-2-重排序与内存可见性的问题"><a href="#1-6-2-重排序与内存可见性的问题" class="headerlink" title="1.6.2  重排序与内存可见性的问题"></a>1.6.2  重排序与内存可见性的问题</h3><p>重排序分类：</p>
<ul>
<li>编译器重排序：对于没有先后依赖关系的语句，编译器可以重新调整语句的执行顺序</li>
<li>CPU 指令重排序：在指令级别，让没有依赖关系的多条指令并行</li>
<li>CPU 内存重排序：CPU 有自己的缓存，指令的执行顺序和写入主内存的顺序不完全一致</li>
</ul>
<p><strong>CPU 内存重排序是造成“内存可见性”问题的主因</strong><br>例：假设有两个线程，线程 1 执行 X = 1 命令 和 a = Y 命令，线程 2 执行 Y = 1 命令 和 b = X 命令。最后 a、b 的结果应该是什么？<br>因为 线程 1 和 线程 2 的执行顺序不确定，所以结果可能是</p>
<ul>
<li>a = 0, b = 1</li>
<li>a = 1, b = 0</li>
<li>a = 1, b = 1</li>
</ul>
<p>正常就这三种可能性，但实际还可能是 a = 0, b = 0，为什么呢？<br>原因是线程 1先执行 X = 1 后执行 a = Y，但此时 X = 1 还在自己的 Store Buffer 里，但在线程2看来，a = Y 和 X = 1 顺序却是颠倒的。指令没有重排序，写入内存的操作被延迟了，也就是内存被重排序了，这就造成内存可见行问题。</p>
<h3 id="1-6-3-as-if-serial-语义"><a href="#1-6-3-as-if-serial-语义" class="headerlink" title="1.6.3&nbsp; as-if-serial 语义"></a>1.6.3&nbsp; as-if-serial 语义</h3><p>对于开发者而言，希望不要有任何的重排序，指令执行顺序和代码顺序严格一致，写内存的顺序也严格和代码顺序一致。<br>对于编译器和CPU，希望尽最大可能进行重排序，提升运行效率。<br><strong>单线程程序的重排序规则</strong>：只要操作之间没有依赖性，编译器和 CPU 就可以任意重排序，因为执行结果不会改变。这也就是 as-if-serial 语义。<br><strong>多线程程序的重排序规则</strong>：编译器和 CPU 只能保证每个线程的 as-if-serial 语义。线程之间的数据依赖和线程影响，需要编译器和 CPU 的上层来决定。</p>
<h3 id="1-6-4-happen-before-是什么"><a href="#1-6-4-happen-before-是什么" class="headerlink" title="1.6.4  happen-before 是什么"></a>1.6.4  happen-before 是什么</h3><p>如果 A happen-before B，意味着 A 的执行结果必须对 B 可见，也就是保证跨线程的内存可见性。<strong>A happen-before B 不代表A一定在B之前执行。</strong><br>基于 happen-before 这种描述方法，JMM 对开发者做出了一系列承诺：</p>
<ul>
<li>单线程中的每个操作，happen-before 对应线程中任意后续操作</li>
<li>对 volatile 变量的写入，happen-before 对应后续对这个变量的读取</li>
<li>对 synchronized 的解锁，happen-before 对应后续对这个锁的加锁</li>
</ul>
<p>对于非 volatile 变量的写入和读取，不在这个承诺之列。通俗来讲，就是JVM对编译器和CPU来说，volatilt 变量不能重排序；非 volatilt 变量可以任意重排序。</p>
<h3 id="1-6-5-happen-before-的传递性"><a href="#1-6-5-happen-before-的传递性" class="headerlink" title="1.6.5  happen-before 的传递性"></a>1.6.5  happen-before 的传递性</h3><p>volatile、synchronized 都具有 happen-before 语义。</p>
<h3 id="1-6-6-C-中的-volatile-关键字"><a href="#1-6-6-C-中的-volatile-关键字" class="headerlink" title="1.6.6  C++中的 volatile 关键字"></a>1.6.6  C++中的 volatile 关键字</h3><p>在 Java 中的 volatile 关键字不仅具有内存可见性，还会禁止 volatile 变量写入和非 volatile 变量写入的重排序；C++ 中的 volatile 关键字不会禁止这种重排序。</p>
<h3 id="1-7-内存屏障"><a href="#1-7-内存屏障" class="headerlink" title="1.7  内存屏障"></a>1.7  内存屏障</h3><p>为了禁止编译器重排序和CPU重排序，在编译器和CPU层面都有对应的指令。<br>编译器的内存屏障，知只是为了告诉编译器不要对指令进行重排序。当变异完成之后，这种内存屏障就消失了。<br>CPU内存屏障是CPU提供的指令，可以由开发者显示调用。</p>
<h3 id="1-7-1-Linux-中的内存屏障"><a href="#1-7-1-Linux-中的内存屏障" class="headerlink" title="1.7.1  Linux 中的内存屏障"></a>1.7.1  Linux 中的内存屏障</h3><p>通过函数 smp_wmb() 插入了一个 Store Barrier 屏障，从而确保了：</p>
<ul>
<li>更新指针的操作，不会被重排序到修改数据之前。</li>
<li>更新指针的时候，Store Cache 被刷新，其他CPU可见<h3 id="1-7-2-JDK-中的内存屏障"><a href="#1-7-2-JDK-中的内存屏障" class="headerlink" title="1.7.2  JDK 中的内存屏障"></a>1.7.2  JDK 中的内存屏障</h3>JDK8开始，Java在 Unsafe 类中提供了三个内存屏障函数(不是最基本的内存屏障)：<pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class Unsafe{
	public native void loadFence();		//loadFence=LoadLoad+LoadStore
    public native void storeFence();	//storeFence=StoreFence+LoadStore
    public native void fullFence();		//fullFence=LoadFence+StoreFence+StoreLoad
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
在理论层面，可以把基本的CPU内存屏障分为4种：</li>
</ul>
<ol>
<li><p>LoadLoad：禁止读和读的重排序</p>
</li>
<li><p>StoreStore：禁止写和写的重排序</p>
</li>
<li><p>LoadStore：禁止读和写的重排序</p>
</li>
<li><p>StoreLoad：禁止写和读的重排序</p>
<h3 id="1-7-3-volatile-实现原理"><a href="#1-7-3-volatile-实现原理" class="headerlink" title="1.7.3  volatile 实现原理"></a>1.7.3  volatile 实现原理</h3><p>实现 volatile 关键字的语义参考做法：</p>
</li>
<li><p>在 volatile 写操作的前面插入一个 StoreStore 屏障。保证 volatile 写操作不会和之前的写操作重排序。</p>
</li>
<li><p>在 volatile 写操作的后面插入一个 StoreLoad 屏障。保证 volatile 写操作不会和之后的读操作重排序。</p>
</li>
<li><p>在 volatile 读操作的后面插入一个 LoadLoad 屏障 + LoadStore 屏障。保证 volatile 读操作不会和之后的读操作、写操作重排序。</p>
<h2 id="1-8-final-关键字"><a href="#1-8-final-关键字" class="headerlink" title="1.8  final 关键字"></a>1.8  final 关键字</h2><h3 id="1-8-1-构造函数溢出问题"><a href="#1-8-1-构造函数溢出问题" class="headerlink" title="1.8.1  构造函数溢出问题"></a>1.8.1  构造函数溢出问题</h3><p>对于构造函数溢出，就是一个对象的构造<strong>并不是“原子的”</strong>，当一个线程正在构造对象时，另外一个线程却可以读到未构造好的“一半对象”。</p>
<h3 id="1-8-2-final-的-happen-before-语义"><a href="#1-8-2-final-的-happen-before-语义" class="headerlink" title="1.8.2  final 的 happen-before 语义"></a>1.8.2  final 的 happen-before 语义</h3><p>解决构造函数溢出的办法：</p>
</li>
<li><p>给变量都加上 volitile 关键字</p>
</li>
<li><p>为 read/write 函数都加上 synchronized 关键字</p>
</li>
<li><p>给变量加上 final 关键字</p>
</li>
</ol>
<p>final 的 happen-before 语义：</p>
<ol>
<li>对 final 域的写（构造函数内部），happen-before 于后续对 final 域所在对象的读</li>
<li>对 final 域所在对象的读，happen-before 于后续对 final 域的读</li>
</ol>
<p>通过这种 happen-before 语义的限定，保证了 final 域的赋值，一定在构造函数之前完成，不会出现另外一个线程读取到了对象，但对象里面的变量却还没有初始化的情形，避免出现构造函数溢出的问题。</p>
<h3 id="1-8-3-happen-before-规则总结"><a href="#1-8-3-happen-before-规则总结" class="headerlink" title="1.8.3  happen-before 规则总结"></a>1.8.3  happen-before 规则总结</h3><ol>
<li>单线程中的每个操作，happen-before 于该线程中任意后续操作</li>
<li>对 volatile 变量的写，happen-before 于后续对这个变量的读</li>
<li>对 synchronized 的解锁，happen-before 于后续对这个锁的加锁</li>
<li>对 final 变量的写，happen-before 于 final 域对象的读，happen-before 于后续对 final 变量的读</li>
</ol>
<p>四个基本规则再加上 hapen-before 的传递性，就构成JVM对开发者的整个承诺<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627392881708-75d6007a-d8cb-455b-acc0-a2b9b64893d2.png#align=left&amp;display=inline&amp;height=375&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=750&amp;originWidth=902&amp;size=256649&amp;status=done&amp;style=none&amp;width=451" alt="image.png"><br>图 1-7  从底向上看 volatile 背后的原理</p>
<h1 id="第二章-Atomic类"><a href="#第二章-Atomic类" class="headerlink" title="第二章 Atomic类"></a>第二章 Atomic类</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627468800067-00b5a7f8-412f-48a4-bb32-0b8bd45b2dbc.png#align=left&amp;display=inline&amp;height=293&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=586&amp;originWidth=540&amp;size=149574&amp;status=done&amp;style=none&amp;width=270" alt="image.png"><br>图 2-1  整个 Concurrent 包的层次体系</p>
<h2 id="2-1-AtomicInteger-和-AtomicLong"><a href="#2-1-AtomicInteger-和-AtomicLong" class="headerlink" title="2.1 AtomicInteger 和 AtomicLong"></a>2.1 AtomicInteger 和 AtomicLong</h2><h3 id="2-1-1-悲观锁与乐观锁"><a href="#2-1-1-悲观锁与乐观锁" class="headerlink" title="2.1.1 悲观锁与乐观锁"></a>2.1.1 悲观锁与乐观锁</h3><p>悲观锁：数据发生并发冲突的概率很大，所以读操作之前就上锁。synchronized 关键字和 ReentrantLock 都是悲观锁的典型例子。<br>乐观锁：数据发生并发冲突的概率很小，所以读操作之前不上锁。等到写操作的时候，再判断数据在此期间是否被其他线程修改了。如果被其他线程修改了，就把数据重新读出来，重复该过程；如果没有被修改，就写回去。判断数据是否被修改，同时写回新值，这两个操作要合成一个原子操作，也就是CAS（Compare And Set）。AtomicInteger就是典型的乐观锁</p>
<h3 id="2-1-2-Unsafe的CAS详解"><a href="#2-1-2-Unsafe的CAS详解" class="headerlink" title="2.1.2 Unsafe的CAS详解"></a>2.1.2 Unsafe的CAS详解</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final boolean compareAndSet(int expect, int update){
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>AtomicInteger 封装过的 compareAndSet 有两个参数。第一个参数 expect 是指变量的旧值（是读出来的值，写回去的时候，希望没有被其他线程修改）；第二个参数 update 是指变量的新值（修改过的，没有写入的值）。当 expect 变量等于当前变量时，说明在修改的期间，没有其他线程对此变量进行过修改，所以可以成功写入，变量被更新为 update，返回 true；否则返回 false；</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该函数有4个参数，第一个是对象（AtomicInteger 变量）；第二个是对象的成员变量（AtomicInteger 里面包的 int 变量 value），它是 long 型整数，常被称为 xxxOffset，意思是某个成员变量在对应的类中的内存偏移量，表示该成员变量本身。<br>无论是 Unsafe 还是 valueOffset，都是静态的，也就是类级别的，所有对象共用的。<br>在转化的时候，先通过反射（getDeclaredField）获取 value 成员变量对应的 Field 对象，再通过 objectFieldOffset 函数转化成 valueOffset。此处的 valueOffset 就代表了 value 变量本身，后面执行CAS操作的时候，不是直接操作 value，而是操作 valueOffset。</p>
<h3 id="2-1-3-自旋与阻塞"><a href="#2-1-3-自旋与阻塞" class="headerlink" title="2.1.3 自旋与阻塞"></a>2.1.3 自旋与阻塞</h3><p>当一个线程拿不到锁的时候，有两种基本的等待策略：<br>策略1：放弃CPU，进入阻塞状态，等待后续被唤醒，再重新被操作系统调度。<br>策略2：不放弃CPU，空转，不断重试，也就是所谓的“自旋”。<br>这两种策略不是互斥的，可以结合使用。</p>
<h2 id="2-2-AtomicBoolean-和-AtomicReference"><a href="#2-2-AtomicBoolean-和-AtomicReference" class="headerlink" title="2.2 AtomicBoolean 和 AtomicReference"></a>2.2 AtomicBoolean 和 AtomicReference</h2><h3 id="2-2-1-为什么需要-AtomicBoolean"><a href="#2-2-1-为什么需要-AtomicBoolean" class="headerlink" title="2.2.1 为什么需要 AtomicBoolean"></a>2.2.1 为什么需要 AtomicBoolean</h3><p>AtomicBoolean：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">if(flag == false){
	flag = true;
    ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>实现 compare 和 set 两个操作合在一起的原子性，这也是CAS提供的功能。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">if(compareAndSet(false, true)){
	...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>AtomicReference：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public final boolean compareAndSet(V expect, V update){
	return unsafe.compareAndSwapObject(this, valueOffset, exprct, update);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="2-2-2-如何支持-boolean-和-double-类型"><a href="#2-2-2-如何支持-boolean-和-double-类型" class="headerlink" title="2.2.2 如何支持 boolean 和 double 类型"></a>2.2.2 如何支持 boolean 和 double 类型</h3><ul>
<li>AtomicBoolean 类型怎么支持？</li>
</ul>
<p>对于用 int 型来代替的，在入参的时候，将 boolean 类型转换成 int 类型；在返回值的时候，将 int 类型 转换成 boolean 类型。</p>
<ul>
<li>double 类型怎么支持？<h2 id="2-3-AtomicStampedReference-和-AtomicMarkanle"><a href="#2-3-AtomicStampedReference-和-AtomicMarkanle" class="headerlink" title="2.3 AtomicStampedReference 和 AtomicMarkanle"></a>2.3 AtomicStampedReference 和 AtomicMarkanle</h2><h3 id="2-3-1-ABA问题与解决方法"><a href="#2-3-1-ABA问题与解决方法" class="headerlink" title="2.3.1 ABA问题与解决方法"></a>2.3.1 ABA问题与解决方法</h3>CAS 都是基于“值”来做比较的。但如果另外一个线程把变量的值从 A 改为 B，再从 B 改回到 A，尽管修改过两次，可是在当前线程做 CAS 操作的时候，却会因为值没变而认为数据没有被其他线程修改过，这就是所谓的<strong>ABA问题</strong>。<br>解决方法：不仅比较“值”，还要比较“版本号”<h3 id="2-3-2-为什么没有-AtomicStampedInteger-AtomictStampedLong"><a href="#2-3-2-为什么没有-AtomicStampedInteger-AtomictStampedLong" class="headerlink" title="2.3.2 为什么没有 AtomicStampedInteger AtomictStampedLong"></a>2.3.2 为什么没有 AtomicStampedInteger AtomictStampedLong</h3>因为要同时比较“值”和“版本号”，而 Integer 型或者 Long 型的 CAS 没有办法同时比较这两个变量，于是只能把值和版本号封装成一个对象，然后通过对象引用的 CAS 来实现。<h3 id="2-3-3-AtomicMarkableReference"><a href="#2-3-3-AtomicMarkableReference" class="headerlink" title="2.3.3 AtomicMarkableReference"></a>2.3.3 AtomicMarkableReference</h3>Pair 里面的版本号是 boolean 类型的，而不是整型的累加变量。因为是 boolean类型，只能有 true、false 两个版本号，所以并不能完全避免 ABA 问题，只是<strong>降低</strong>了 ABA 发生的概率。<h2 id="2-4-AtomicIntegerFieldUpdater、AtomicLongFieldUpdater-和-AtomicReferenceFieldUpdater"><a href="#2-4-AtomicIntegerFieldUpdater、AtomicLongFieldUpdater-和-AtomicReferenceFieldUpdater" class="headerlink" title="2.4 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater"></a>2.4 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater</h2><h3 id="2-4-1-为什么需要-AtomicXXXFieldUpdater"><a href="#2-4-1-为什么需要-AtomicXXXFieldUpdater" class="headerlink" title="2.4.1 为什么需要 AtomicXXXFieldUpdater"></a>2.4.1 为什么需要 AtomicXXXFieldUpdater</h3>如果一个类是自己编写的，则可以在编写的时候把成员变量定义为 Atomic 类型。如果是一个已有的类，在不能更改其源码的情况下，要想实现对其成员变量的原子操作，就需要 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater。<h3 id="2-4-2-限制条件"><a href="#2-4-2-限制条件" class="headerlink" title="2.4.2 限制条件"></a>2.4.2 限制条件</h3>要想使用 AtomicIntegerFieldUpdater 修改成员变量，成员变量必须是 volatile 的 int 类型（不能是 Integer 包装类）<h2 id="2-5-AtomicIntegerArray、AtomicLongArray-和-AtomicReferenceArray"><a href="#2-5-AtomicIntegerArray、AtomicLongArray-和-AtomicReferenceArray" class="headerlink" title="2.5 AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray"></a>2.5 AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray</h2>Concurrent 包提供了 AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray 三个数组元素的原子操作。注：并不是说对整个数组的操作是原子的，而是针对数组中一个元素的原子操作而言。<h3 id="2-5-1-使用方法"><a href="#2-5-1-使用方法" class="headerlink" title="2.5.1 使用方法"></a>2.5.1 使用方法</h3>相比与 AtomicInteger 的 getAndIncrement() 函数，这里只是多了一个传入参数：数组的下标 i<pre class="line-numbers language-java" data-language="java"><code class="language-java">public final boolean compareAndSet(int i, int expect, int update){...}
public final int getAndDecrement(int i){...}
public final int getAndSet(int i, int newValue){...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="2-5-2-实现原理"><a href="#2-5-2-实现原理" class="headerlink" title="2.5.2 实现原理"></a>2.5.2 实现原理</h3>其底层的 CAS 函数用的还是 compareAndSwapInt，但是把数组下标 i 转化成对应的内存偏移量，所用的方法和之前的 AtomicInteger 不太一样。<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static long	byteOffset(int i){
	return ((long) i &lt;&lt; shift) + base;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
把下标 i 换成对应的内存地址，用到 shift 和 base 两个变量。这两个变量都是 AtomicIntegerArray 的静态成员变量，用 Unsafe 类的 arrayBaseOffset 和 arrayIndexScale 两个函数来获取。<br>base 表示数组的首地址的位置，scale 表示一个数组元素的大小，i 的偏移量则等于 i * scale + base。但为了优化性能，使用了位移操作，shift 表示 scale 中 1 的位置（scale 是2的整数次方）。所以，偏移量的计算变成上面代码中的：i &lt;&lt; shift + base，表达的意思就是：i * scale + base。<h2 id="2-6-Striped64-与-LongAdder"><a href="#2-6-Striped64-与-LongAdder" class="headerlink" title="2.6 Striped64 与 LongAdder"></a>2.6 Striped64 与 LongAdder</h2><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627472292002-4bfbcc8d-a019-4c93-8df0-b5a918bfaff5.png#align=left&amp;display=inline&amp;height=208&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=416&amp;originWidth=1458&amp;size=161164&amp;status=done&amp;style=none&amp;width=729" alt="image.png"><br>图 2-2  Striped64 相关的类的继承层次<h3 id="2-6-1-LongAdder-原理"><a href="#2-6-1-LongAdder-原理" class="headerlink" title="2.6.1 LongAdder 原理"></a>2.6.1 LongAdder 原理</h3>AtomicLong 内部是一个 volatile long 型变量，由多个线程对这个变量进行CAS操作。多个线程同时对一个变量进行CAS操作，在高并发的场景下仍不够快，如果再要提高性能，该怎么做？<br>把一个变量拆分成多份，变为多个变量，有些类似于 ConcurrentHashMap 的分段锁的例子。把一个 Long 型拆成一个 base 变量外加多个 Cell，每个 Cell 包装了一个 Long 型变量。当多个线程并发累加的时候，如果并发度低，就直接加到 base 变量上；如果并发度高，冲突大，平摊到这些 Cell 上。在最后取值的时候，再把 base 和这些 Cell 求 sum 运算。<h3 id="2-6-2-最终一致性"><a href="#2-6-2-最终一致性" class="headerlink" title="2.6.2 最终一致性"></a>2.6.2 最终一致性</h3>在 sum 求和函数中，并没有对 cells[] 数组加锁。也就是说，一边有线程对其执行求和操作，一边还有线程修改数组里的值，也就是最终一致性，而不是强一致性。<h3 id="2-6-3-伪共享于缓存行填充"><a href="#2-6-3-伪共享于缓存行填充" class="headerlink" title="2.6.3 伪共享于缓存行填充"></a>2.6.3 伪共享于缓存行填充</h3></li>
</ul>
<p><strong>@sun.misc.Contended</strong><br>每个CPU都有自己的缓存。缓存与主内存进行数据交换的基本单位叫 Cache Line（缓存行）。要刷新到主内存的时候，最少要刷新64字节。</p>
<h3 id="2-6-4-LongAdder-核心实现"><a href="#2-6-4-LongAdder-核心实现" class="headerlink" title="2.6.4 LongAdder 核心实现"></a>2.6.4 LongAdder 核心实现</h3><p>当一个线程调用 add(x) 的时候，首先会尝试使用 casBase 把 x 加到 base 变量上。如果不成功，则再用 a.cas(..) 函数尝试把 x 加到 Cell 数组的某个元素上。如果还不成功，最后再调用 longAccumulate(..) 函数。<br>注：Cell[] 数组的大小始终是2的整数次方，在运行中会不断扩容，每次扩容都是增长2倍。</p>
<h3 id="2-6-5-LongAccumulator"><a href="#2-6-5-LongAccumulator" class="headerlink" title="2.6.5 LongAccumulator"></a>2.6.5 LongAccumulator</h3><p>LongAccumulator 与 LongAdder 构造函数对比：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public LongAdder() {...}
public LongAccumulator(LongBinaryOperator accumulatorFunction, long identity) {...}

public interface LongBinaryOperator {
	long applyAsLong(long left, long right);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>LongAdder 只能进行累加操作，并且初始值默认为0；LongAccumulator 可以自己定义一个二元操作符，并且传入一个初始值。操作符的左值，就是 base 变量或者 Cells[] 中元素的当前值；右值，就是 add() 函数传入的参数 x。</li>
<li>LongAccumulator 的 accumulate(x) 函数与 LongAdder 的 add(x) 函数类似，最后都是调用 Striped64 的 LongAccumulate(…) 函数。唯一的差别是 LongAdder 的 add(x) 函数调用的是 casBase(b, b+x)，LongAccumulator 调用的是casBase(b, r)，其中，r = function.applyAsLong(b = base, x)。<h3 id="2-6-6-DoubleAdder-与-DoubleAccumulator"><a href="#2-6-6-DoubleAdder-与-DoubleAccumulator" class="headerlink" title="2.6.6 DoubleAdder 与 DoubleAccumulator"></a>2.6.6 DoubleAdder 与 DoubleAccumulator</h3><h1 id="第三章-Lock-与-Condition"><a href="#第三章-Lock-与-Condition" class="headerlink" title="第三章 Lock 与 Condition"></a>第三章 Lock 与 Condition</h1><h2 id="3-1-互斥锁"><a href="#3-1-互斥锁" class="headerlink" title="3.1 互斥锁"></a>3.1 互斥锁</h2><h3 id="3-1-1-锁的可重入性"><a href="#3-1-1-锁的可重入性" class="headerlink" title="3.1.1 锁的可重入性"></a>3.1.1 锁的可重入性</h3>可重入锁（ReentrantX）是指当一个线程调用 object.lock() 拿到锁，进入互斥区后，在此调用 object.lock()，仍然可以拿到该锁。通常的锁都要设计成可重入的，否则会发生死锁。<h3 id="3-1-2-类继承层次"><a href="#3-1-2-类继承层次" class="headerlink" title="3.1.2 类继承层次"></a>3.1.2 类继承层次</h3><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627524371322-ea5e81d2-281f-47f7-af41-a300dc377b4a.png#align=left&amp;display=inline&amp;height=380&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=760&amp;originWidth=1172&amp;size=272917&amp;status=done&amp;style=none&amp;width=586" alt="image.png"><br>图 3-1  与 ReentrantLock 相关类之间的继承关系<br>I 表示界面（Interface），A表示抽象类（Abstract Class），C表示类（Class），$表示内部类。实线表示继承关系，虚线表示引用关系。<br>常用方法 Lock()/unLock()。lock() 不能被中断，对应的 lockInterrupttibly() 可以被中断。<h3 id="3-1-3-锁的公平性-vs-非公平性"><a href="#3-1-3-锁的公平性-vs-非公平性" class="headerlink" title="3.1.3 锁的公平性 vs. 非公平性"></a>3.1.3 锁的公平性 vs. 非公平性</h3>Sync 是一个抽象类，它有两个子类 FairSync 与 NonfairSync，分别对应公平锁和非公平锁<br>一个新的线程来了之后，看到有很多线程在排队，自己排到队伍末尾，这叫公平；线程来了之后直接去抢锁，这叫不公平。默认设置的是非公平锁，为了提高效率，减少线程切换。<h3 id="3-1-4-锁实现的基本原理"><a href="#3-1-4-锁实现的基本原理" class="headerlink" title="3.1.4 锁实现的基本原理"></a>3.1.4 锁实现的基本原理</h3>Sync 的父类 AbstractQueuedSynchronizer 常被称作队列同步器（AQS）<br>为了实现一把具有阻塞或唤醒功能的锁，需要几个核心要素：</li>
</ul>
<ol>
<li>需要一个 state 变量，标记该锁的状态。state 变量至少有两个值：0、1。对 state 变量的操作，要确保线程安全，也就是会用到 CAS。</li>
<li>需要记录当前是哪个线程持有锁。</li>
<li>需要底层支持对一个线程进行阻塞或唤醒操作。</li>
<li>需要有一个队列维护所有阻塞的线程。这个队列也必须是线程安全的无锁队列，也需要用到 CAS。</li>
</ol>
<p>state 取值不仅可以是0、1，还可以大于1，就是为了支持锁的可重入性。例如，同样一个线程，调用5次lock，state 会变成5；然后调用5次 unlock，state 减为0.<br>当 state = 0 时，没有线程持有锁，exclusiveOwnerThread = null；<br>当 state = 1 时，有一个线程持有锁，exclusiveOwnerThread = 该线程；<br>当 state &gt; 1 时，说明该线程重入了该锁。</p>
<p>在当前线程调用 park()，该线程就会堵塞；在另外一个线程中，调用 unpark(Thread t)，传入一个被阻塞的线程，就可以唤醒阻塞在 park() 地方的线程。unpark(Thread t)实现了一个线程对另一个线程的“精准唤醒”。</p>
<h3 id="3-1-5-公平与非公平的-lock-实现"><a href="#3-1-5-公平与非公平的-lock-实现" class="headerlink" title="3.1.5 公平与非公平的 lock() 实现"></a>3.1.5 公平与非公平的 lock() 实现</h3><h3 id="3-1-6-阻塞队列与唤醒机制"><a href="#3-1-6-阻塞队列与唤醒机制" class="headerlink" title="3.1.6 阻塞队列与唤醒机制"></a>3.1.6 阻塞队列与唤醒机制</h3><p>park() 函数返回有两种情况：<br>情况1：其他线程调用了 unpark(Thread t)<br>情况2：其他线程调用了 t.interrupt()。<strong>注意</strong>，lock()不能响应中断，但LockSupport.park() 会响应中断。</p>
<h3 id="3-1-7-unlock-实现分析"><a href="#3-1-7-unlock-实现分析" class="headerlink" title="3.1.7 unlock() 实现分析"></a>3.1.7 unlock() 实现分析</h3><p>release() 里面做两件事：tryRelease(..) 函数释放锁；unparkSuccessor(..) 函数唤醒队列中的后继者。<br>因为是排他锁，只有已经持有锁的线程才有资格调用 release(..)，这意味者没有其他线程与它争论。所以在 tryRelease(..) 函数中，对 state 值的修改，不需要CAS操作，直接减1即可。</p>
<h3 id="3-1-8-lockInterruptibly-实现分析"><a href="#3-1-8-lockInterruptibly-实现分析" class="headerlink" title="3.1.8 lockInterruptibly() 实现分析"></a>3.1.8 lockInterruptibly() 实现分析</h3><p>当 parkAndCheckInterrupt() 返回 true 的时候，说明有其他线程发送中断信号，直接抛出 InterruptedException，跳出 for 循环，整个函数返回。</p>
<h3 id="3-1-9-tryLock-实现分析"><a href="#3-1-9-tryLock-实现分析" class="headerlink" title="3.1.9 tryLock() 实现分析"></a>3.1.9 tryLock() 实现分析</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean tryLock() {
	return sync.nonfairTryAcquire(1);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>tryLock() 实现基于调用非公平锁的 tryAcquire(..)，对 state 进行 CAS 操作，如果操作成功就拿到锁；如果操作不成功则直接返回 false，也不阻塞。</p>
<h2 id="3-2-读写锁"><a href="#3-2-读写锁" class="headerlink" title="3.2 读写锁"></a>3.2 读写锁</h2><p>读写锁（ReentrantReadWriteLock）就是读线程和读线程之间可以不用互斥了。</p>
<h3 id="3-2-1-类继承层次"><a href="#3-2-1-类继承层次" class="headerlink" title="3.2.1 类继承层次"></a>3.2.1 类继承层次</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627554404502-d9bbfa53-1756-433c-ac03-f4e0ca7f0f82.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=532&amp;originWidth=1282&amp;size=60598&amp;status=done&amp;style=none&amp;width=641" alt="image.png"><br>图 3-3  ReentrantReadWriteLock 类继承层次<br>ReentrantWriteLock 实现了该接口</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">ReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock rLock = rwLock.readLock();
rLock.lock();
rLock.unlock();
Lock wLock = rwLock.writeLock();
wLock.lock();
wLock.unlock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-2-2-读写锁实现的基本原理"><a href="#3-2-2-读写锁实现的基本原理" class="headerlink" title="3.2.2 读写锁实现的基本原理"></a>3.2.2 读写锁实现的基本原理</h3><p>ReadLock 和 WriteLock 是两把锁，实际上是同意把锁的两个视图（读线程和写线程）<br>读线程和读线程不互斥（可以同时拿到这把锁），读线程和写线程互斥，写线程和写线程互斥。<br>当 state = 0 时，说明既没有线程持有读锁，也没有线程持有写锁；当 state != 0 时，要么有线程持有读锁，要么有线程持有写锁，两者不能同时成立，因为读和写互斥。这时再进一步通过 sharedCount(state) 和 exclusiveCount(state) 判断到底是读线程还是写线程持有了该锁。</p>
<h3 id="3-2-3-AQS-的两对模板方法"><a href="#3-2-3-AQS-的两对模板方法" class="headerlink" title="3.2.3 AQS 的两对模板方法"></a>3.2.3 AQS 的两对模板方法</h3><p>acquire/release、acquireShared/releaseShared 是 AQS 里面的两对模板方法。互斥锁和读写锁的<strong>写锁</strong>都是基于 acquire/release 模板方法来实现的，读写锁的<strong>读锁</strong>都是基于 acquireShared/releaseShared 模板方法来实现的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627558228347-5ddf70e5-8314-4a7b-b47c-1a7860fff866.png#align=left&amp;display=inline&amp;height=358&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=716&amp;originWidth=1024&amp;size=256886&amp;status=done&amp;style=none&amp;width=512" alt="image.png"><br>图 3-4  四种锁的策略的实现示意图<br>最终对应关系：</p>
<ol>
<li>读锁的公平实现：Sync.tryAcquireShared() + FairSync 中的两个覆写的子函数。</li>
<li>读锁的非公平实现：Sync.tryAcquireShared() + NonfairSync 中的两个覆写的子函数。</li>
<li>写锁的公平实现：Sync.tryAcquire() + FairSync 中的两个覆写的子函数。</li>
<li>写锁的非公平实现：Sync.tryAcquire() + NonfairSync 中的两个覆写的子函数。</li>
</ol>
<p>对于公平，不论是读锁，还是写锁，只要队列中有其他线程在排队，就不能直接去抢锁，要排在队列尾部。<br>对于非公平，读锁和写锁的实现策略略有差异。<strong>写锁</strong>，写线程能抢锁，前提是 state = 0，只有在没有其他线程持有读锁或写锁的情况下，它才有机会去抢锁。当 state != 0，由于持有写锁线程，再次重入。写线程是非公平的，不断去抢（一直返回 false）。但对于读线程，读线程和读线程不互斥的，对于读线程的非公平，要做一些“约束”。当发现队列的第一个元素是写线程，读线程要阻塞一下。</p>
<h3 id="3-2-4-WriteLock-公平-vs-非公平实现"><a href="#3-2-4-WriteLock-公平-vs-非公平实现" class="headerlink" title="3.2.4 WriteLock 公平 vs. 非公平实现"></a>3.2.4 WriteLock 公平 vs. 非公平实现</h3><ol>
<li>tryAcquire() 实现分析</li>
</ol>
<ul>
<li>if(c != 0) and w == 0，说明当前一定是读线程拿着锁，写锁一定拿不到，返回false。</li>
<li>if(c != 0) and w != 0，说明当前一定是写线程拿着锁，执行 current != getExclusiveOwnerThread() 的判断，发现 ownerThread 不是自己，返回 false。</li>
<li>if(c != 0) and w == 0，且 curent = getExclusiveOwnerThread()，才会走到 if(w + exclusiveCount(acquires) &gt; MAX_COUNT)。判断重入次数，重入次数超过最大值，抛出异常。</li>
<li>if(c = 0)，说明当前既没有读线程，也没有写线程持有该锁。可以通过CAS操作开抢，抢成功后，调用 setExclusiveOwnerThread(current)，把 ownerThread 设成自己</li>
</ul>
<ol start="2">
<li>tryRelease(..) 实现分析</li>
</ol>
<p>因为写锁是排他的，在当前线程持有写锁的时候，其他线程既不会持有写锁，也不会持有读锁。所以，这里对 state 值的调减不需要 CAS 操作，直接减一即可。</p>
<h3 id="3-2-5-ReadLock-公平-vs-非公平实现"><a href="#3-2-5-ReadLock-公平-vs-非公平实现" class="headerlink" title="3.2.5 ReadLock 公平 vs. 非公平实现"></a>3.2.5 ReadLock 公平 vs. 非公平实现</h3><ol>
<li><p>tryAcquireShared(..) 实现分析</p>
</li>
<li><p>tryReleaseShared(..) 实现分析</p>
<h2 id="3-3-Condition"><a href="#3-3-Condition" class="headerlink" title="3.3 Condition"></a>3.3 Condition</h2><h3 id="3-3-1-Condition-与-Lock-的关系"><a href="#3-3-1-Condition-与-Lock-的关系" class="headerlink" title="3.3.1 Condition 与 Lock 的关系"></a>3.3.1 Condition 与 Lock 的关系</h3><p>Condition 本身也是接口，其功能和 wait/notify 类似<br>Condition 必须和 Lock 一起使用</p>
<h3 id="3-3-2-Condition-的使用场景"><a href="#3-3-2-Condition-的使用场景" class="headerlink" title="3.3.2 Condition 的使用场景"></a>3.3.2 Condition 的使用场景</h3><p>一个用数组实现的阻塞队列，执行 put(..) 操作的时候，队列满了，生产者线程被阻塞；执行 take() 操作的时候，队列为空，消费者线程被阻塞。</p>
<h3 id="3-3-3-Condition-实现原理"><a href="#3-3-3-Condition-实现原理" class="headerlink" title="3.3.3 Condition 实现原理"></a>3.3.3 Condition 实现原理</h3><p>读写锁中的 ReadLock 是不支持 Condition 的，读写锁的写锁和互斥锁都支持 Condition。虽然它们都调用的是自己的内部类 Sync，但内部类 Sync 都继承子、自 AQS。</p>
<h3 id="3-3-4-await-实现分析"><a href="#3-3-4-await-实现分析" class="headerlink" title="3.3.4 await() 实现分析"></a>3.3.4 await() 实现分析</h3></li>
<li><p>线程调用 await() 的时候，肯定已经拿到了锁。</p>
</li>
<li><p>在线程执行 wait 操作之前，必须先释放锁。</p>
</li>
<li><p>线程从 wait 中被唤醒后，必须用 acquireQueued(node, savedState) 函数重新拿锁。</p>
</li>
<li><p>checkInterruptWhileWaiting(node) 代码在 park(this) 代码之后，是为了检测在 park 期间是否收到过中断信号。</p>
</li>
<li><p>isOnSyncQueue(node) 用于判断该 Node 是否在 AQS 的同步队列里。</p>
<h3 id="3-3-5-awaitUninterruptibly-实现分析"><a href="#3-3-5-awaitUninterruptibly-实现分析" class="headerlink" title="3.3.5 awaitUninterruptibly() 实现分析"></a>3.3.5 awaitUninterruptibly() 实现分析</h3><p>awaitUninterruptibly() 不会响应中断，其函数的定义不会有中断异常抛出，继续执行 while 循环。</p>
<h3 id="3-3-6-notify-实现分析"><a href="#3-3-6-notify-实现分析" class="headerlink" title="3.3.6 notify() 实现分析"></a>3.3.6 notify() 实现分析</h3><p>在调用 notify() 的时候，必须先拿到锁，然后从队列中取出 firstWait，唤醒它。</p>
<h2 id="3-4-StampedLock"><a href="#3-4-StampedLock" class="headerlink" title="3.4 StampedLock"></a>3.4 StampedLock</h2><h3 id="3-4-1-为什么引入-StampedLock"><a href="#3-4-1-为什么引入-StampedLock" class="headerlink" title="3.4.1 为什么引入 StampedLock"></a>3.4.1 为什么引入 StampedLock</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627607333589-9265d52d-df36-40eb-aa83-6f4cacebb61d.png#align=left&amp;display=inline&amp;height=140&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=280&amp;originWidth=1464&amp;size=46273&amp;status=done&amp;style=none&amp;width=732" alt="image.png"><br>图 3-1  三种锁的并发度对比<br>因为 ReentrantLock 采用的“悲观锁”的策略。当第一个线程拿到锁之后，第二个、第三个读线程还可以拿到锁，使得写线程一直拿不到锁，可能导致写线程“饿死”。虽然在其公平或非公平的实现中，都尽量避免这种情形，但还是有可能发生。StampedLock 引入了“乐观锁策略”，读的时候不加锁，读出来发现数据被修改了，再升级为“悲观锁”，相当于降低了“读”的地位，把抢锁的天平往“写”的一方倾斜了一下，避免写线程被锁死。</p>
<h3 id="3-4-2-使用场景"><a href="#3-4-2-使用场景" class="headerlink" title="3.4.2 使用场景"></a>3.4.2 使用场景</h3><p>首先，执行 move 操作的时候，要加写锁，写操作和写操作也是互斥的。关键在于读的时候，用了一个“乐观锁”sl.tryOptimisticRead()，相当于在读之前给数据的状态做了一个“快照”。然后，把数据拷贝到内存里面，再用之前，再对比一次版本号。如果版本号变了，则说明在读的期间有其他线程修改了数据。读出来的数据废弃，重新获取读锁。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">long stamp = sl.tryOptimisticRead();	//在读之前，获取数据版本号
double currentX = x, currentY = y;		//读：将一份数据拷贝到线程的栈内存中
if (!sl.validate(stamp)){...}			//读之后：判断读出来数据是否可以使用（所谓可以使用，是指读的期间没有其他线程修改过数据）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这三行关键代码对顺序非常敏感，不能有重排序。因为 state 变量已经是 volatile，所以可以禁止重排序，但 stamp 并不是 volatile 的。为此，在 volatile(stamp) 函数里面插入<strong>内存屏障</strong></p>
<h3 id="3-4-3-“乐观锁”的实现原理"><a href="#3-4-3-“乐观锁”的实现原理" class="headerlink" title="3.4.3 “乐观锁”的实现原理"></a>3.4.3 “乐观锁”的实现原理</h3><h3 id="3-4-4-悲观锁-写：“阻塞”与“自旋”策略实现差异"><a href="#3-4-4-悲观锁-写：“阻塞”与“自旋”策略实现差异" class="headerlink" title="3.4.4 悲观锁/写：“阻塞”与“自旋”策略实现差异"></a>3.4.4 悲观锁/写：“阻塞”与“自旋”策略实现差异</h3><h1 id="第四章-同步工具类"><a href="#第四章-同步工具类" class="headerlink" title="第四章 同步工具类"></a>第四章 同步工具类</h1><h2 id="4-1-Semaphore"><a href="#4-1-Semaphore" class="headerlink" title="4.1 Semaphore"></a>4.1 Semaphore</h2><p>Semaphore 也就是信号量，提供了资源数量的并发访问控制<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627613239272-6e8be334-c32d-4e30-8cda-f15d006180bf.png#align=left&amp;display=inline&amp;height=291&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=582&amp;originWidth=922&amp;size=171058&amp;status=done&amp;style=none&amp;width=461" alt="image.png"><br>图 4-1  Semaphore 相关类的继承体系</p>
<h2 id="4-2-CountDownLatch"><a href="#4-2-CountDownLatch" class="headerlink" title="4.2 CountDownLatch"></a>4.2 CountDownLatch</h2><p>因为是基于AQS阻塞队列实现的，所以可以让多个线程阻塞在 state = 0 条件上，通过 countDown() 一直累减 state，减到0后一次性唤醒所有线程。<br>假设初始总数为M，N个线程 await()，M个线程countDown()，减到0之后，N个线程被唤醒。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627614623869-84a05c1a-9e1f-46cf-8540-2e6add340093.png#align=left&amp;display=inline&amp;height=164&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=328&amp;originWidth=1184&amp;size=161694&amp;status=done&amp;style=none&amp;width=592" alt="image.png"><br>图 4-3  多个线程阻塞在 await() 示意图</p>
<h3 id="4-2-1-CountDownLatch-使用场景"><a href="#4-2-1-CountDownLatch-使用场景" class="headerlink" title="4.2.1 CountDownLatch 使用场景"></a>4.2.1 CountDownLatch 使用场景</h3><p>一个主线程要等待10个 Worker 线程工作完毕才退出，就能使用 CountDownLatch 来实现</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CountDownLatch doneSignal = new CountDownLatch(10);	//初始为10
doneSignal.await();		//主线程调用该方法，阻塞在这
doneSignal.countDown();	//10个Worker线程，每个线程工作完毕后，调用1次countDown()，计算器减1。当减到0之后，主线程被唤醒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627613787116-34d14399-f88f-4f45-9140-7fc01032eb06.png#align=left&amp;display=inline&amp;height=217&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=434&amp;originWidth=1030&amp;size=134647&amp;status=done&amp;style=none&amp;width=515" alt="image.png"><br>图 4-2  CountDownLatch 相关类的继承层次</p>
<h3 id="4-2-2-await-实现分析"><a href="#4-2-2-await-实现分析" class="headerlink" title="4.2.2 await() 实现分析"></a>4.2.2 await() 实现分析</h3><p>await() 调用的是AQS模版方法<br>从 tryAcquireShared(..) 方法的实现来看，只要 state != 0，调用 await() 方法的线程便会被释放入AQS的阻塞队列，进入阻塞状态。</p>
<h3 id="4-2-3-countDown-实现分析"><a href="#4-2-3-countDown-实现分析" class="headerlink" title="4.2.3 countDown() 实现分析"></a>4.2.3 countDown() 实现分析</h3><p>countDown() 调用的AQS的模版方法 releaseShared()，里面的 tryReleaseShared(..) 被 CountDownLatch.Sync 重新实现。只有 state = 0，tryReleaseShared(..) 才会返回 true，然后执行 doReleaseShared(..)，一次性唤醒队列中所有阻塞的线程。</p>
<h2 id="4-3-CyclicBarrier"><a href="#4-3-CyclicBarrier" class="headerlink" title="4.3 CyclicBarrier"></a>4.3 CyclicBarrier</h2><h3 id="4-3-1-CyclicBarrier-使用场景"><a href="#4-3-1-CyclicBarrier-使用场景" class="headerlink" title="4.3.1 CyclicBarrier 使用场景"></a>4.3.1 CyclicBarrier 使用场景</h3><p>等待所有线程到达同步点再开始下一个阶段。</p>
<h3 id="4-3-2-CyclicBarrier-实现分析"><a href="#4-3-2-CyclicBarrier-实现分析" class="headerlink" title="4.3.2 CyclicBarrier 实现分析"></a>4.3.2 CyclicBarrier 实现分析</h3></li>
<li><p>CyclicBarrier 是可以被重用的。所有线程互相等待，到齐后一起被唤醒各自执行接下来的逻辑。每一轮被称为一个 Generation，就是一个同步点</p>
</li>
<li><p>CyclicBarrier 会响应中断。线程没有到齐，如果收到中断信号，所有阻塞线程会被唤醒，就是 breakBarrier() 函数。然后 count 被重置为初始值（parties），重新开始。</p>
</li>
<li><p>barrierAction 只会被执行一次。</p>
<h2 id="4-4-Exchanger"><a href="#4-4-Exchanger" class="headerlink" title="4.4 Exchanger"></a>4.4 Exchanger</h2><h3 id="4-4-1-Exchanger-使用场景"><a href="#4-4-1-Exchanger-使用场景" class="headerlink" title="4.4.1 Exchanger 使用场景"></a>4.4.1 Exchanger 使用场景</h3><p>Exchanger 用于线程之间交换数据</p>
<h3 id="4-4-2-Exchanger-实现原理"><a href="#4-4-2-Exchanger-实现原理" class="headerlink" title="4.4.2 Exchanger 实现原理"></a>4.4.2 Exchanger 实现原理</h3><p>Exchanger 的核心机制和 Lock 一样，也是 CAS + park/unpark。<br>每个线程在调用 exchange(..) 函数交换数据的时候，会先创建一个 Node 对象，这个 Node 对象就是对该线程的包装，里面包含了两个字段：1个是线程要交互的数据，另1个是该线程自身。<strong>注：Node 本身是继承自AtomicReference 的，所以除了这两个字段，Node 还有第3个字段，记录的是对方所要交换的数据，初始为 NULL。</strong><br>Slot 的 AtomicReference 就是指向的一个 Node，通过 Slot 和 Node 相结合，实现了2个线程之间的数据交换。线程1持有数据 item1，线程2持有数据 item2，各自调用 exchange(..)，会各自生成一个 Node。而 Slot 只会指向2个 Node 中的1个：如果是线程1先调用的 exchange(..)，那么 Slot 就指向 Node1 ，线程1阻塞，等待线程2来交换；反之，如果是线程2先调用的 exchange(..) ，那么 Slot 就指向 Node2，线程2阻塞，等待线程1来交换数据。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627616545389-1eab47a9-d671-4800-aa15-82146c306660.png#align=left&amp;display=inline&amp;height=183&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=366&amp;originWidth=1400&amp;size=165648&amp;status=done&amp;style=none&amp;width=700" alt="image.png"><br>图 4-3  Slot 与 Node 相结合实现2个线程交换数据<br>一个 Slot 只能支持2个线程之间交换数据，要实现多个线程并行地交换数据，需要多个Slot，因此在 Exchange 里面定义了 Slot 数组：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private volatile Slot[] arena = new Slot[CAPACITY];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="4-4-3-exchanger-V-x-实现分析"><a href="#4-4-3-exchanger-V-x-实现分析" class="headerlink" title="4.4.3 exchanger(V x) 实现分析"></a>4.4.3 exchanger(V x) 实现分析</h3><h2 id="4-5-Phaser"><a href="#4-5-Phaser" class="headerlink" title="4.5 Phaser"></a>4.5 Phaser</h2><h3 id="4-5-1-用-Phaser-替代-CyclicBarrier-和-CountDownLatch"><a href="#4-5-1-用-Phaser-替代-CyclicBarrier-和-CountDownLatch" class="headerlink" title="4.5.1 用 Phaser 替代 CyclicBarrier 和 CountDownLatch"></a>4.5.1 用 Phaser 替代 CyclicBarrier 和 CountDownLatch</h3></li>
<li><p>用 Phaser 替代 CyclicBarrier</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Phaser ph = new Phaser(10);		//初始为10
ph.awaitAdance(ph.getPhase());	//主线程调用该方法，阻塞在这。
ph.arrive();	//每个线程工作完成之后，调用1次arrive()。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>用 Phaser 替代 CountDownLatch</p>
<h3 id="4-5-2-Phaser-新特性"><a href="#4-5-2-Phaser-新特性" class="headerlink" title="4.5.2 Phaser 新特性"></a>4.5.2 Phaser 新特性</h3><p>特性1：动态调整线程个数<br>CyclicBarrier 所要同步的线程个数是在构造函数中指定的，之后不能更改。而 Phaser 可以在运行期间动态地调整要同步的线程个数。</p>
</li>
</ol>
<p>特性2：层次 Phaser<br>父 Phaser 并不用感知子 Phaser 的存在，当子 Phaser 中注册的参与者数量大于0时，会把自己向父节点注册；当子 Phaser 中注册的参与者数量等于0时，会自动向父节点解注册。父 Phaser 把子 Phaser 当作一个正常参与的线程就可以了。</p>
<h3 id="4-5-3-state-变量解析"><a href="#4-5-3-state-变量解析" class="headerlink" title="4.5.3 state 变量解析"></a>4.5.3 state 变量解析</h3><p>state 变量在构造函数中是如何赋值的？</p>
<ul>
<li>当 parties = 0 时，state 被赋予一个 EMPTY 常量，常量为1；</li>
<li>当 parties != 0 时，把 phase 值左移32位；把 parties 左移16位；然后 parties 也作为最低的16位，3个值做或操作，赋值给 state。<h3 id="4-5-4-阻塞与唤醒（Treiber-Strack）"><a href="#4-5-4-阻塞与唤醒（Treiber-Strack）" class="headerlink" title="4.5.4 阻塞与唤醒（Treiber Strack）"></a>4.5.4 阻塞与唤醒（Treiber Strack）</h3>基于上述的 state 变量，对其执行 CAS 操作，并进行相应的阻塞与唤醒。右边的主线程会调用 awaitAdcance() 进行阻塞；左边的 arrive() 会对 state 进行 CAS 的累减操作，当未到达的线程数减到0时，唤醒右边阻塞的主线程。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627617608223-bdb01b47-380d-4670-b33c-8e619d85299e.png#align=left&amp;display=inline&amp;height=174&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=348&amp;originWidth=1200&amp;size=149015&amp;status=done&amp;style=none&amp;width=600" alt="image.png"><br>图 4-10  基于 state 的 CAS 的阻塞与唤醒示意图<h3 id="4-5-5-arrive-函数分析"><a href="#4-5-5-arrive-函数分析" class="headerlink" title="4.5.5 arrive() 函数分析"></a>4.5.5 arrive() 函数分析</h3>arrive() 和 arriveAndDeregister() 内部调用的都是 doArrive(boolean)函数。arrive() 把“未达到线程数”减1； arriveAndDeregister() 把“未到达线程数”和“下一轮的总线程数”都减1.<h3 id="4-5-6-awaitAdvance-函数分析"><a href="#4-5-6-awaitAdvance-函数分析" class="headerlink" title="4.5.6 awaitAdvance() 函数分析"></a>4.5.6 awaitAdvance() 函数分析</h3><h1 id="第五章-并发容器"><a href="#第五章-并发容器" class="headerlink" title="第五章 并发容器"></a>第五章 并发容器</h1><h2 id="5-1-BlockingQueue"><a href="#5-1-BlockingQueue" class="headerlink" title="5.1 BlockingQueue"></a>5.1 BlockingQueue</h2>在所有的并发容器中，BlockingQueue 是最常见的一种。BlockingQueue 是一个带阻塞功能的队列当入队列时，若队列已满，则阻塞调用者；当出队列时，若队列为空，则阻塞调用者。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1627629198547-f0abef5c-0260-4a0f-b015-68dca993a9df.png#align=left&amp;display=inline&amp;height=149&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=298&amp;originWidth=1316&amp;size=121006&amp;status=done&amp;style=none&amp;width=658" alt="image.png"><br>图 5-1  BlockingQueue 的各种实现类<h3 id="5-1-1-ArrayBlockingQueue"><a href="#5-1-1-ArrayBlockingQueue" class="headerlink" title="5.1.1 ArrayBlockingQueue"></a>5.1.1 ArrayBlockingQueue</h3>ArrayBlockingQueue 是一个用数组实行的环形队列，在构造函数中，会要求传入数组的容量。<pre class="line-numbers language-java" data-language="java"><code class="language-java">public ArrayBlockingQueue(int capacity, boolean fair) {...}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="5-1-2-LinkedBlockingQueue"><a href="#5-1-2-LinkedBlockingQueue" class="headerlink" title="5.1.2 LinkedBlockingQueue"></a>5.1.2 LinkedBlockingQueue</h3>LinkedBlockingQueue 是一种基于单向链表的阻塞队列。因为队头和队尾是2个指针分开操作的，所以用了2把锁 + 2个条件，同时有1个 AtomicInteger 的原子变量记录 count 数。<br>LinkedBlockingQueue 和 ArrayBlockingQueue 的实现差异：</li>
</ul>
<ol>
<li><p>为了提高并发度，用2把锁，分别控制队头、队尾的操作。意味着在 put(..) 和 put(..) 之间、take(..) 和 take(..) 之间互斥的，put(..) 和 take(..) 之间并不互斥的。但对于 count 变量，双方都需要操作，所以必须是原子类型。</p>
</li>
<li><p>因为各自拿了一把锁，所以当需要调用对方的 condition 的 signal 时，还必须再加上对方的锁，就是 signalNotEmpty() 和 signalNotFull() 函数。</p>
</li>
<li><p>不仅 put 会通知 take，take 也会通知 put。当 put 发现非满时，也会通知其他 put 线程；当 take 发现非空的时候，也会通知其他 take 线程。</p>
<h3 id="5-1-3-PriorityBlockingQueue"><a href="#5-1-3-PriorityBlockingQueue" class="headerlink" title="5.1.3 PriorityBlockingQueue"></a>5.1.3 PriorityBlockingQueue</h3><p>队列通常是先进先出的，而 PriorityQueue 是按照元素的优先级从小到大出队列的。PriorityQueue 中的2个元素之间需要可以比较大小，并实现 Comparable 接口。<br>在阻塞的实现方面，和 ArrayBlockingQueue 的机制相似，主要区别是用数组实现了一个二叉堆，从而实现按优先级从小到大出队列。另一个区别是没有 notFull 条件，当元素个数超过数组长度时，执行扩容操作。</p>
<h3 id="5-1-4-DelayQueue"><a href="#5-1-4-DelayQueue" class="headerlink" title="5.1.4 DelayQueue"></a>5.1.4 DelayQueue</h3><p>DelayQueue 即延迟队列，也就是一个按延迟时间从小到大出队的 PriorityQueue。所谓延迟时间，就是“未来将要执行的时间” - “当前时间”。为此，放入 DelayQueue 中的元素，必须实现 Delayed 接口。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Delayed extends Comparable&lt;Delayed&gt;{
	long getDelay(TimeUnit unit);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>关于该接口，有两点说明：</p>
</li>
<li><p>如果 getDelay 的返回值小于或等于0，则说明该元素到期，需要从队列中拿出来执行。</p>
</li>
<li><p>该接口首先继承了 Comparable 接口，所以要实现该接口，必须实现 Comparable 接口</p>
</li>
</ol>
<p>不是每放入一个元素，都需要通知等待的线程。放入的元素，如果其延迟时间大于当前堆顶的元素延迟时间，就没必要通知等待的线程；只有当延迟时间是最小的，在堆顶时，才有必要通知等待的线程，也就是上面代码中的 if(q.peek()==e)段落。</p>
<h3 id="5-1-5-SynchronousQueue"><a href="#5-1-5-SynchronousQueue" class="headerlink" title="5.1.5 SynchronousQueue"></a>5.1.5 SynchronousQueue</h3><p>SynchronousQueue 是一种特殊的 BlockingQueue，它本身没有容量。先调 put(..)，线程会阻塞；直到另一个线程调用 take()，两个线程才同时解锁，反之亦然。<br>如果是公平模式，则用 TransferQueue 实现；如果是非公平模式，则用 TransferStack 实现。put/take 都调用了 transfer(..) 接口。而 TransferQueue 和 TransferStack 分别实现了这个接口。该接口在 SynchronousQueue 内部。如果是 put(..)，则第1个参数就是对应的元素；如果是 take()，则是第1个为 null。后2个参数分别为是否设置超时和对应的超时时间。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">abstract static class Transferer{
	abstract Object transfer(Object e, boolean timed, long nanos);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol>
<li>TransferQueue</li>
</ol>
<p>TransferQueue 是一个基于单向链表而实现的队列，通过 head 和 tail 2个指针记录头部和尾部。初始的时候，head 和 tail 会指向一个空节点。<br>TransferQueue 的工作原理<br>阶段(a)：队列中是一个空的节点，head/tail都指向这个空节点。<br>阶段(b)：3个线程分别调用 put，生成3个 QNode，进入队列。<br>阶段(c)：来了一个线程调用 take，会和队列头部的第1个 QNode 进行配对。<br>阶段(d)：第1个 QNode 出队列。<br><strong>关键点：</strong>put 节点和 take 节点一旦相遇，就会配对出队列，所以在队列中不可能同时存在 put 节点和 take 节点，要么所有节点都是 put 节点，要么所有节点都是 take 节点。</p>
<ol start="2">
<li>TransferStack</li>
</ol>
<p>TransferStack 是一个单向链表，只需要 head 指针就能实现入栈和出栈操作。链表中的节点有三种状态，REQUEST 对应 take 节点，DATE 对应 put 节点，二者配对后，会生成一个 FULFILLING 节点，入栈，然后 FULLING 节点和被配对的节点一起出栈。<br>TransferStack 的工作原理<br>阶段(a)：head 指向 NULL。不同于 TransferQueue，这里没有空的头节点。<br>阶段(b)：3个线程调用3次 put，依次入栈。<br>阶段(c)：线程4调用 take，和栈顶的第1个元素配对，生成 FULLFILLING 节点，入栈。<br>阶段(d)：栈顶的2个元素同时入栈。</p>
<h2 id="5-2-BlockingDeque"><a href="#5-2-BlockingDeque" class="headerlink" title="5.2 BlockingDeque"></a>5.2 BlockingDeque</h2><p>BlockingDeque 定义了一个阻塞的双端队列接口。该接口继承了 BlockingQueue 接口的同时，增加对应双端队列操作接口。该接口只有一个实现，就是 LinkedBlockingDeque</p>
<h2 id="5-3-CopyOnWrite"><a href="#5-3-CopyOnWrite" class="headerlink" title="5.3 CopyOnWrite"></a>5.3 CopyOnWrite</h2><p>CopyOnWrite 指在“写”的时候，不是直接“写”源数据，而是把数据拷贝一份进行修改，再通过悲观锁或者乐观锁的方式写回。</p>
<h3 id="5-3-1-CopyOnWriteArrayList"><a href="#5-3-1-CopyOnWriteArrayList" class="headerlink" title="5.3.1 CopyOnWriteArrayList"></a>5.3.1 CopyOnWriteArrayList</h3><h3 id="5-3-2-CopyOnWriteArraySet"><a href="#5-3-2-CopyOnWriteArraySet" class="headerlink" title="5.3.2 CopyOnWriteArraySet"></a>5.3.2 CopyOnWriteArraySet</h3><p>CopyOnWriteArraySet 就是用 Array 实现的一个 Set，保证所有元素都不重复。</p>
<h2 id="5-4-ConcurrentLinkedQueue-Deque"><a href="#5-4-ConcurrentLinkedQueue-Deque" class="headerlink" title="5.4 ConcurrentLinkedQueue/Deque"></a>5.4 ConcurrentLinkedQueue/Deque</h2><ol>
<li>初始化</li>
</ol>
<p>初始化的时候，head 和 tail 都执行一个 NULL 节点。</p>
<ol start="2">
<li>入队列</li>
</ol>
<p>初始的时候，队列中有1个节点 item1，tail 指向该节点，假设线程1要入队 item2 节点：<br>step1：p = tail，q = p.next = NULL。<br>step2：对p的 next 执行 CAS 操作，追加 item2，成功之后，p = tail。所以上面的 casTail 函数不会执行，直接返回。此时 tail 指针没有变化。<br>step3：p = tail，q = p.next。<br>step4：q != NULL，因此不会入队新节点。p，q都后移1位。<br>step5：q = NULL，对p的 next 执行 CAS 操作，入队 item3 节点。<br>step6：p != t，满足条件，执行上面的 casTail 操作，tail 后移2个位置，到达队列尾部。<br>关键点：</p>
<ul>
<li>即使 tail 指针没有移动，只要对p的 next 指针成功进行 CAS 操作，就算成功入队列。</li>
<li>只有当 p != tail 的时候，才会后移 tail 指针。也就是说，每连续追加2个节点，才后移1次 tail 指针。即使 CAS 失败，也可以由下一个线程来移动 tail 指针。</li>
</ul>
<ol start="3">
<li>出队列</li>
</ol>
<p>假设初始的时候 head 指向空节点，队列中有 item1，item2，item3 三个节点。<br>step1：p = head，q = p.next，p != q。<br>step2：后移p指针，使得 p = q。<br>step3：出队列。关键点：此处并没有直接删除 item1 节点，只是把该节点的 item 通过 CAS 操作置为了 NULL。<br>step4：p != head，此时队列中有了2个 NULL 节点，，再前移1次 head 指针，对其进行 updateHead 操作。<br>关键点：</p>
<ul>
<li>出队列的判断并非观察 tail 指针的位置，而是依赖于 head 指针后续的节点是否为 NULL 这一条件。</li>
<li>只要对节点的 item 执行 CAS 操作，置为 NULL 成功，则出队列成功。即使 head 指针没有成功移动，也可以由下一个线程继续完成。</li>
</ul>
<ol start="4">
<li>队列判空</li>
</ol>
<p>因为 head/tail 并不是精确地指向队列头部和尾部，所以不能简单地通过比较 head/tail 指针来判断队列是否为空，而是需要从 head 指针开始遍历，找第1个不为 NULL 的节点。如果找到，则队列不为空；如果找不到，则队列为空。</p>
<h2 id="5-5-ConcurrentHashMap"><a href="#5-5-ConcurrentHashMap" class="headerlink" title="5.5 ConcurrentHashMap"></a>5.5 ConcurrentHashMap</h2><p>HashMap 通常的实现方式是“数组 + 链表”，这种方式被称为“拉链法”。</p>
<h3 id="5-5-1-JDK7-中的实现方式"><a href="#5-5-1-JDK7-中的实现方式" class="headerlink" title="5.5.1 JDK7 中的实现方式"></a>5.5.1 JDK7 中的实现方式</h3><ol>
<li>构造函数分析<ol>
<li>第1个参数，initialCapacity 是整个 ConcurrentHashMap 的初始大小。用 initialCapacity 除以 ssize，是每个 Segment 的初始大小。这里也会保证 Segment 里面 HashEntry[] 数组的大小是2的整数次方。</li>
<li>第2个参数，loadFactor 即负载因子，传给了 Segment 内部。当每个 Segment 的元素达到一定阀值，进行 rehash。Segment 的个数不能扩容，但每个 Segment 的内部可以扩容。</li>
<li>第3个参数，concurrenyLevel 是“并发度”，也就是 Segment 数组的大小。这个值一旦在构造函数中设定，之后不能再扩容。为了提升 hash 的计算性能，会保证数组的大小始终是2的整数次方。</li>
</ol>
</li>
<li>put(..) 函数分析</li>
</ol>
<p>进入 scanAndLockForPut(key, hash, value) 做什么？<br>一是拿不到锁，不立即阻塞，而是先自旋，若自旋到一定次数仍未拿到锁，再调用 lock() 阻塞；<br>二是在自旋的过程中遍历了链表，若发现没有重复的节点，则提前新建一个节点，为后面再插入节省时间。</p>
<ol start="3">
<li>扩容<ol>
<li>函数的参数，也就是将要加入的最新节点。在扩容完成之后，把该节点加入新的 Hash 表。</li>
<li>整个数组的长度是2的整数次方，每次按二倍扩容，而 hash 函数就是对数组长度取模，即 node.hash &amp; sizeMask。因此，如果元素之前处于第i个位置，当再次 hash 时，必然处于第i个或第 i+oldCapacity 个位置。</li>
<li>lastRun 到链表末尾的所有元素，其 hash 值没有改变，所以不需要依次重新拷贝，只需把这部分链表链接到新链表锁对应的位置就可以，也就是 new Table[lastIdx] = lastRun。lastRun 之前的元素则需要依次拷贝</li>
</ol>
</li>
<li>get 实现分析</li>
</ol>
<p>整个 get 过程是两次 hash</p>
<ol>
<li>第一次 hash，函数为 (h&gt;&gt;&gt;segmentShift) &amp; segmentMask，计算出所在的 Segment；</li>
<li>第二次 hash，函数为 h &amp; (tab.length -  1)，即h对数组长度取模，找到 Segment 里面对应的 HashEntry 数组下标，然后遍历该位置的链表</li>
</ol>
<p>整个读过程完全没有加锁，而是使用了 UNSAFE.getObjectVolatile 函数。</p>
<h3 id="5-5-2-JDK8-中的实现方式"><a href="#5-5-2-JDK8-中的实现方式" class="headerlink" title="5.5.2 JDK8 中的实现方式"></a>5.5.2 JDK8 中的实现方式</h3><p>链表和红黑树之间可以相互转换：初始的时候是链表，当链表中的元素超过某个阀值时，把链表转换成红黑树；反之，当红黑树中的元素个数小于某个阀值，再转换为链表。<br>为什么 JDK8 要做这种改变？在 JDK7 中的分段锁，有三个好处：</p>
<ol>
<li>减少 Hash 冲突，避免一个槽里有太多元素。</li>
<li>提高读和写的并发度。段与段之间相互独立。</li>
<li>提供扩容的并发度。扩容的时候，不是整个 ConcurrentHashMap 一起扩容，而是每个 Segment 独立扩容。</li>
</ol>
<p>针对这三个好处，JDK8 相应的处理方式：</p>
<ol>
<li>使用红黑树，当一个槽里有很多元素时，其查询和更新速度会比链表快很多，Hash 冲突的问题由此得到很好的解决。</li>
<li>加锁的粒度，并非整个 ConcurrentHashMap，而是对每个头节点分别加锁，即并发度，就是 Node 数组长度，初始长度为16，和在 JDK7 中初始 Segment 的个数相同。</li>
<li>并发扩容，在 JDK7 中，一旦 Segment 的个数在初始化的时候确立，不能再更改，并发度被固定。之后只是在每个 Segment 内部扩容，这意味着每个 Segment 独立扩容，互不影响，不存在并发扩容的问题。在 JDK8 中，相当于只有1个 Segment，当一个线程要扩容 Node 数组的时候，其他线程还要读写。<h2 id="5-6-ConcurrentSkipListMap-Set"><a href="#5-6-ConcurrentSkipListMap-Set" class="headerlink" title="5.6 ConcurrentSkipListMap/Set"></a>5.6 ConcurrentSkipListMap/Set</h2>ConcurrentSkipListMap 是一个 key 无序的 HashMap，HashMap 则是 key 有序的，实现了 NavigableMap 接口，此接口又继承了 SortedMap 接口。<h3 id="5-6-1-ConcurrentSkipListMap"><a href="#5-6-1-ConcurrentSkipListMap" class="headerlink" title="5.6.1 ConcurrentSkipListMap"></a>5.6.1 ConcurrentSkipListMap</h3>为什么要使用 SkipList 实现 Map？<br>在 Java 的 util 包中，有一个非线程安全的 HashMap，也就是 TreeMap，是 key 有序的，基于红黑树实现。而在 Concurrent 包中，提供的 key 有序的 HashMap，也就是 ConcurrentSkipMap，是基于 SkipList（调查表）来实现的。<h3 id="5-6-2-ConcurrentSkipListSet"><a href="#5-6-2-ConcurrentSkipListSet" class="headerlink" title="5.6.2 ConcurrentSkipListSet"></a>5.6.2 ConcurrentSkipListSet</h3><h1 id="第六章-线程池与-Future"><a href="#第六章-线程池与-Future" class="headerlink" title="第六章 线程池与 Future"></a>第六章 线程池与 Future</h1><h2 id="6-1-线程池的实现原理"><a href="#6-1-线程池的实现原理" class="headerlink" title="6.1 线程池的实现原理"></a>6.1 线程池的实现原理</h2>当没有任务的时候，线程是进入睡眠一小段时间？还是进入阻塞？如果进入阻塞，如何让唤醒？</li>
</ol>
<ul>
<li>做法1：不使用阻塞队列，只使用一般的线程安全的队列，也无阻塞—唤醒机制。当队列为空时，线程池中的线程只能睡眠一会，然后醒来去看队列中有没有新任务到来，如此不断轮询。</li>
<li>做法2：不使用阻塞队列，但在队列外部、线程池内部实现了阻塞—唤醒机制。</li>
<li>做法3：使用阻塞队列</li>
</ul>
<p>做法3最完善，既避免了线程池内部自己实现阻塞—唤醒机制的麻烦，也避免了做法1的睡眠—轮询带来的资源消耗和延迟。</p>
<h2 id="6-2-线程池的类继承体系"><a href="#6-2-线程池的类继承体系" class="headerlink" title="6.2 线程池的类继承体系"></a>6.2 线程池的类继承体系</h2><p>两个核心类：ThreadPoolExecutor 和 ScheduledThreadPoolExecutor，后者不仅可以执行某个任务，还可以周期性地执行任务。<br>向线程池中提交的每个任务，都必须实现 Runnable 接口，通过最上面的 Executor 接口中的 execute(Runnable command) 向线程池提交任务。<br>在 ExecutorService 中，定义了线程池的关闭接口 shutdown()，还定义了可以返回值的任务，也就是 Callable。</p>
<h2 id="6-3-ThreadPoolExecutor"><a href="#6-3-ThreadPoolExecutor" class="headerlink" title="6.3 ThreadPoolExecutor"></a>6.3 ThreadPoolExecutor</h2><h3 id="6-3-1-核心数据结构"><a href="#6-3-1-核心数据结构" class="headerlink" title="6.3.1 核心数据结构"></a>6.3.1 核心数据结构</h3><p>每一个线程是一个 Worker 对象。Worder 是 ThreadPoolExecutor 的内部类。Worder 继承于 AQS，也就是 Worker 本身就是一把锁。</p>
<h3 id="6-3-2-核心配置参数解释"><a href="#6-3-2-核心配置参数解释" class="headerlink" title="6.3.2 核心配置参数解释"></a>6.3.2 核心配置参数解释</h3><ol>
<li>corePoolSize：在线程池始终维护的线程个数。</li>
<li>maxPoolSize：在 corePoolSize 已满、队列也满的情况下，扩充至此值。</li>
<li>keepAliveTime/TimeUnit：maxPoolSize 中的空闲线程，销毁所需要的时间，总线程数收缩回 corePoolSize。</li>
<li>blockingQueue：线程池所用的队列类型。</li>
<li>threadFactory：线程创建工厂，可以自定义，也可以默认。</li>
<li>RejectedExecutionHandler：corePoolSize 已满，队列已满，maxPoolSize 已满，最后的拒绝策略。</li>
</ol>
<ul>
<li></li>
</ul>
<p>6个配置参数的处理流程：<br>Step1：判断当前线程数是否大于或等于 coolPoolSize。如果小于，则新建线程执行；如果大于，则进入 Step2。<br>Step2：判断队列是否已满。如未满，则放入；如已满，则进入 step3。<br>Step3：判断当前线程数是否大于或等于 maxPoolSize。如果小于，则新建线程执行；如果大于，则进入 step4。<br>Step4：根据拒绝策略，拒绝任务<br>总结：首先判断 corePoolSize，其次判断 blockingQueue 是否已满，接着判断 maxPoolSize，最后使用拒绝策略。基于这种流程，如果队列是无界的，将永远没有机会走到 step3，也即 maxPoolSize 没有使用，也一定不会走到 step4。</p>
<h3 id="6-3-3-线程池的优雅关闭"><a href="#6-3-3-线程池的优雅关闭" class="headerlink" title="6.3.3 线程池的优雅关闭"></a>6.3.3 线程池的优雅关闭</h3><ol>
<li>线程池的生命周期</li>
</ol>
<p>线程池有两个关闭函数，shutdown() 和 shutdownNow()，这两个函数会让线程池切换到不同的状态。在队列为空，线程池也为空之后，进入 TIDYING 状态；最后执行一个钩子函数 terminated()，进入 TERMINATED 状态，线程池才“寿终正寝”。状态前移只会从小的状态值往大的状态值迁移，不会逆向迁移。</p>
<ol start="2">
<li>正确关闭线程池的步骤</li>
</ol>
<p>在调用 shutdown() 和 shutdownNow() 之后，线程池并不会立即关闭，接下来需要调用 awaitTermination() 来等待线程池关闭。awaitTermination(..) 不断循环判断线程池是否到达了最终状态 TERMINATED，如果是，就返回；如果不是，则通过 termination 条件变量阻塞一段时间，“苏醒”之后，继续判断。</p>
<ol start="3">
<li><p>shutdown() 与 shutdownNow() 的区别</p>
<ol>
<li>前者不会清空任务队列，会等所有任务执行完成，后者再清空任务队列。</li>
<li>前者只会中断空闲的线程，后者会中断所有线程。<h3 id="6-3-4-任务的提交过程分析"><a href="#6-3-4-任务的提交过程分析" class="headerlink" title="6.3.4 任务的提交过程分析"></a>6.3.4 任务的提交过程分析</h3><h3 id="6-3-5-任务的执行过程分析"><a href="#6-3-5-任务的执行过程分析" class="headerlink" title="6.3.5 任务的执行过程分析"></a>6.3.5 任务的执行过程分析</h3>场景1：当调用 shutdown() 的时候，所有线程都处于空闲状态。<br>这意味着任务队列一定是空的。此时，所有线程都会阻塞在 getTask() 函数的地方。然后，所有线程都会收到 interruptIdleWorkers() 发来的中断信号，getTask()  返回 null，所有 Worker 都会退出 while 循环，之后执行 processWorkerExit。<br>场景2：当调用 shutdown() 的时候，所有线程都处于忙碌状态。<br>此时，队列可能是空的，可能是非空的。interruptIdleWorkers() 内部的 tryLock 调用失败，什么都不会做，所有线程会继续执行自己当前的任务。之后所有线程会执行完队列中的任务，直到队列为空，getTask() 才会返回 null。之后，和场景1一样，退出 while 循环。<br>场景3：当调用 shutdown() 的时候，部分线程忙碌，部分线程空闲。<br>有部分线程空闲，说明队列一定是空的，这些线程肯定阻塞在 getTask() 函数的地方。空闲的这些线程会和场景1一样处理，不空闲的线程会和场景2一样处理。<h3 id="6-3-6-线程池的4种拒绝策略"><a href="#6-3-6-线程池的4种拒绝策略" class="headerlink" title="6.3.6 线程池的4种拒绝策略"></a>6.3.6 线程池的4种拒绝策略</h3></li>
</ol>
</li>
<li><p>让调用者直接在自己的线程里面执行，线程池不做处理。</p>
</li>
<li><p>线程池直接抛出异常。</p>
</li>
<li><p>线程池直接把任务丢掉，当作什么也没有发生。</p>
</li>
<li><p>把队列里面最老的任务删除掉，把该任务放入队列中。</p>
<h2 id="6-4-Callable-与-Future"><a href="#6-4-Callable-与-Future" class="headerlink" title="6.4 Callable 与 Future"></a>6.4 Callable 与 Future</h2><h2 id="6-5-ScheduledThreadPoolExecutor"><a href="#6-5-ScheduledThreadPoolExecutor" class="headerlink" title="6.5 ScheduledThreadPoolExecutor"></a>6.5 ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor 实现了按时间调度来执行任务，两方面：</p>
</li>
<li><p>延迟执行任务：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public ScheduledFuture &lt;?&gt; schedule(Runable command, long delay, TimeUnit unit);
public &lt;V&gt;ScheduledFuture &lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>周期执行任务：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public ScheduledFuture &lt;?&gt; scheduleAtFixedRate(Runable command, long initalDelay, TimeUnit unit);
public &lt;V&gt;ScheduledFuture &lt;V&gt; schedulWithFixedRate(Runable command, long initalDelay, long delay, TimeUnit unit);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>两个函数的区别：</p>
</li>
</ol>
<ul>
<li>AtFixedRate：按固定频率执行，与任务本身执行时间无关。但有个前提条件，任务执行时间必须小于间隔时间。</li>
<li>WithFixedDelay：按固定间隔执行，与任务本身执行时间有关。<h3 id="6-5-1-延迟执行和周期性执行的原理"><a href="#6-5-1-延迟执行和周期性执行的原理" class="headerlink" title="6.5.1 延迟执行和周期性执行的原理"></a>6.5.1 延迟执行和周期性执行的原理</h3><h3 id="6-5-2-延迟执行"><a href="#6-5-2-延迟执行" class="headerlink" title="6.5.2 延迟执行"></a>6.5.2 延迟执行</h3>传进去的是一个 Runnable，外加延迟时间 delay。<h3 id="6-5-3-周期性执行"><a href="#6-5-3-周期性执行" class="headerlink" title="6.5.3 周期性执行"></a>6.5.3 周期性执行</h3>包装一个 ScheduledFutureTask 对象，只是在延迟时间参差之外多了一个周期参数，然后放入 DelayedWorkerQueue 就结束了。</li>
</ul>
<p>withFixedRate 和 atFixedRate 的区别体现在 setNextRunTime 里面。</p>
<ul>
<li>如果是 atFixedRate，period &gt; 0，下一次开始执行时间等于上一次开始执行时间 + period；</li>
<li>如果是 withFixedRate，period &lt; 0，下一次开始执行时间等于 triggerTime(-p)，为 now + (-period)，now 即是上一次执行的结束时间。<h2 id="6-6-Executors-工具类"><a href="#6-6-Executors-工具类" class="headerlink" title="6.6 Executors 工具类"></a>6.6 Executors 工具类</h2><h1 id="第七章-ForkJoinPool"><a href="#第七章-ForkJoinPool" class="headerlink" title="第七章 ForkJoinPool"></a>第七章 ForkJoinPool</h1><h2 id="7-1-ForkJoinPool-用法"><a href="#7-1-ForkJoinPool-用法" class="headerlink" title="7.1 ForkJoinPool 用法"></a>7.1 ForkJoinPool 用法</h2>例1：快排<br>第一步：利用数组的第一个元素把数组划分成两半，左边数组里面的元素小于或等于该元素，右边数组里面的元素比该元素大；<br>第二步：对左右的2个子数组分别排序。<h2 id="7-2-核心数据结构"><a href="#7-2-核心数据结构" class="headerlink" title="7.2 核心数据结构"></a>7.2 核心数据结构</h2><h2 id="7-3-工作窃取队列"><a href="#7-3-工作窃取队列" class="headerlink" title="7.3 工作窃取队列"></a>7.3 工作窃取队列</h2>窃取算法是指一个 Worker 线程在执行完毕自己队列中的任务之后，可以窃取其他线程队列中的任务来执行，从而实现负载均衡，以防有的线程很空闲，有的线程很忙。这个过程要用到工作窃取队列。<br>这个队列只有三个操作：</li>
</ul>
<ol>
<li>Worker 线程自己，在队列头部，通过对 queueTop 指针执行加、减操作，实现入队或出队，这是单线程的；</li>
<li>其他 Worker 线程，在队列尾部，通过对 queueBase 进行累加，实现出队操作，也就是窃取，这是多线程的，需要通过 CAS 操作。</li>
</ol>
<p>关键点：</p>
<ol>
<li><p>整个队列是环形的，也就是一个数组实现的 RingBuffer。并且 queueBase 会一直累加，不会减少；queueTop 会累加、减小。最后，queueBase、queueTop 的值都会大于整个数组的长度，只是计算数组的下标的时候，会取 queueTop &amp; (queue.length-1)，queueBase &amp; (queue.length-1)。因为 queue.length 是2的整数次方，这里也就是对 queue.length 是2的整数次方，这里也是对 queue.length 进行取模操作。</p>
<ol>
<li>当 queueTop - queueBase = queue.length-1 的时候，队列为满，此时需要扩容；</li>
<li>当 queueTop = queueBase 的时候，队列为空，Worker 线程即将进入阻塞状态</li>
</ol>
</li>
<li><p>当队列满了之后会扩容，所以被称为是动态的。</p>
<h2 id="7-4-ForkJoinPool-状态控制"><a href="#7-4-ForkJoinPool-状态控制" class="headerlink" title="7.4 ForkJoinPool 状态控制"></a>7.4 ForkJoinPool 状态控制</h2><h3 id="7-4-1-状态变量-ctl-解析"><a href="#7-4-1-状态变量-ctl-解析" class="headerlink" title="7.4.1 状态变量 ctl 解析"></a>7.4.1 状态变量 ctl 解析</h3><p>ctl 变量的64比特位被分为五部分：<br>AC：最高的16个比特位，表示 Active 线程数 -parallelism，parallelism 是上面的构造函数传进去的参数；<br>TC：次高的16个比特位，表示 Total 线程数 -parallelism；<br>ST：1个比特位，如果是1，表示整个 ForkJoinPool 正在关闭；<br>EC：15个比特位，表示阻塞栈的栈顶线程的 wait count；<br>ID：16个比特位，表示阻塞栈的栈顶线程对应的 poolIndex。</p>
<h3 id="7-4-2-阻塞栈-Treiber-Stack"><a href="#7-4-2-阻塞栈-Treiber-Stack" class="headerlink" title="7.4.2 阻塞栈 Treiber Stack"></a>7.4.2 阻塞栈 Treiber Stack</h3><p>要实现多个线程的阻塞、唤醒，除了 park/unpark 这一对操作原语，还需要一个无锁链表实现的阻塞队列，把所有阻塞的线程串在一起。<br>在 ForkJoinPool 中，没有使用阻塞队列，而是使用了阻塞栈。把所有空闲的 Worker 线程放在一个栈里面，这个栈同样通过链来实现，名为 Treiber Stack。<br>首先，ForkJoinWorkerThread 有一个 poolIndex 变量，记录了自己在 ForkJoinWorkerThread[] 数组中的下标位置，poolIndex 变量就相当于每个 ForkJoinPoolWorkerThread 对象的地址；其次 ForkJoinWorkerThread 还有一个 nextWait 变量，记录了前一个阻塞线程的 poolIndex，这个 nextWait 变量就相当于链表的 next 指针，把所有的阻塞线程串联在一起，组成一个Treiber Stack。<br>最后，ctl 变量的最低16位，记录了栈的栈顶线程的 poolIndex；中间的15位，记录了栈顶的线程被阻塞的次数，也称为 wait count。</p>
<h3 id="7-4-3-ctl-变量的初始值"><a href="#7-4-3-ctl-变量的初始值" class="headerlink" title="7.4.3 ctl 变量的初始值"></a>7.4.3 ctl 变量的初始值</h3><p>因为在初始的时候，ForkJoinPool 中的线程个数为0，所以 AC = 0 - parallelism，TC = 0 - parallelism。这意味着只有高32位的AC、TC 两个部分填充了值，低32位都是0填充。</p>
<h3 id="7-4-4-ForkJoinWorkerThread-状态与个数分析"><a href="#7-4-4-ForkJoinWorkerThread-状态与个数分析" class="headerlink" title="7.4.4 ForkJoinWorkerThread 状态与个数分析"></a>7.4.4 ForkJoinWorkerThread 状态与个数分析</h3><p>ForkJoinPool 中的线程可能的状态有三种：</p>
</li>
<li><p>空闲状态（放在Treiber Stack里面）</p>
</li>
<li><p>活跃状态（正在执行某个 ForkJoinTask，未阻塞）</p>
</li>
<li><p>阻塞状态（正在执行某个 ForkJoinTask，但阻塞了，于是调用 join，等待另外一个任务的结果返回）</p>
</li>
</ol>
<p>ctl更好地反映出了三种状态：<br>高32位：u = (int)(ctl&gt;&gt;&gt;32)，然后 u 又拆分成 tc、ac 两个16位；<br>低32位：e = (int)ctl</p>
<ol>
<li>e&gt;0，说明 Treiber Stack 不为空，有空闲线程；e = 0，说明没有空闲线程；</li>
<li>ac&gt;0，说明有活跃线程；ac &lt;= 0，说明没有空闲线程，并且还未超出 parallelism；</li>
<li>tc&gt;0，说明总线程数 &gt; parallelism。</li>
</ol>
<p>tc 与 ac 的差值，也就是总线程数与活跃线程数的差异，在 ForkJoinPool 中有另外一个变量 blockedCount 记录。<br>所以，通过 crl 和 blockedCount 这两个变量，可以知道在整个 ForkJoinPool 中所有空闲线程、活跃线程以及阻塞线程的数量。</p>
<h2 id="7-5-Worker-线程的阻塞-唤醒"><a href="#7-5-Worker-线程的阻塞-唤醒" class="headerlink" title="7.5 Worker 线程的阻塞-唤醒"></a>7.5 Worker 线程的阻塞-唤醒</h2><h3 id="7-5-1-阻塞-入栈"><a href="#7-5-1-阻塞-入栈" class="headerlink" title="7.5.1 阻塞-入栈"></a>7.5.1 阻塞-入栈</h3><p>函数的第一个参数就是要阻塞的线程，第二个参数是当前的 ctl 变量的值。入栈，也就是3步：<br>第一步：w.nextWait = (int)c，即使 w.nextWait 指针，指向栈顶；<br>第二步：long nc = (long)(v &amp; E_MASK) | (c - AC_UNIT) &amp; (AC_MASK|TC_MASK))，即新的栈顶就是当前的线程w，同时把 ac 的值减1，即活跃线程数减1；<br>第三步：将 nc 通过 CAS 赋值给 ctl 变量 UNSAFE。compareAndSwapLong(this, ctlOffset, c, nc)。<br>此时入栈成功，ctl 变量更新成功。最后，调用 LockSupport.park(this) 阻塞自己。但是在这期间做了很多其他事情：</p>
<ol>
<li>统计 stealCount。</li>
<li>判断 ForkJoinPool 是否关闭，以及是否所有线程都处于空闲状态，整个 ForkJoinPool 是否处于静默状态</li>
<li>在阻塞之前，为了保险，又重新扫描了一遍队列，观察是否有任务可以执行。</li>
</ol>
<h3 id="7-5-2-唤醒-出栈"><a href="#7-5-2-唤醒-出栈" class="headerlink" title="7.5.2 唤醒-出栈"></a>7.5.2 唤醒-出栈</h3><p>当 signalWorker 函数的参数为空，它会唤醒栈顶的线程，如：e &gt; 0，说明栈不为空，此时 e 的最低16位，存储的是栈顶线程的poolIndex，取出来唤醒；e = 0，说明栈为空，此时开一个新线程。</p>
<h2 id="7-6-任务的提交过程分析"><a href="#7-6-任务的提交过程分析" class="headerlink" title="7.6 任务的提交过程分析"></a>7.6 任务的提交过程分析</h2><p>如何区分一个任务是内部任务还是外部任务？<br>可以通过调用该函数的线程类型判断。如果线程类型是 ForkJoinWorkerThread，说明是线程池内部的某个线程在调用该函数，则把该任务放入该线程的局部队列；否则，是外部线程在调用该函数，则将该任务加入全局队列。</p>
<h3 id="7-6-1-内部提交任务-pushTask"><a href="#7-6-1-内部提交任务-pushTask" class="headerlink" title="7.6.1 内部提交任务 pushTask"></a>7.6.1 内部提交任务 pushTask</h3><p>由于工作窃取队列的特性，其对 queueTop 的操作是单线程的，所以此处不需要执行 CAS 操作。当 queueTop - queueBase = 0 的时候，队列为空，此处为了保险，写作 queueTop - queueBase &lt;= 2，不影响正确性。</p>
<h3 id="7-6-2-外部提交任务-addSubmission"><a href="#7-6-2-外部提交任务-addSubmission" class="headerlink" title="7.6.2 外部提交任务 addSubmission"></a>7.6.2 外部提交任务 addSubmission</h3><p>外部多个线程会调用该函数，所以要加锁，入队列和扩容的逻辑和线程内部的队列基本相同，最后，调用 signalWork()，通知一个空闲线程来取。</p>
<h2 id="7-7-工作窃取算法：任务的执行过程分析"><a href="#7-7-工作窃取算法：任务的执行过程分析" class="headerlink" title="7.7 工作窃取算法：任务的执行过程分析"></a>7.7 工作窃取算法：任务的执行过程分析</h2><h3 id="7-7-1-顺序锁-SeqLock"><a href="#7-7-1-顺序锁-SeqLock" class="headerlink" title="7.7.1 顺序锁 SeqLock"></a>7.7.1 顺序锁 SeqLock</h3><ol>
<li>读线程在读取共享数据之前先读取 sequence number，在读取数据之后仔读一次 sequence number，如果两次的值不同，说明在此期间有其他线程修改了数据，此次读取数据无效重新读取；</li>
<li>写线程，在写入数据之前，累加一次 sequence number，在写入数据之后，再累加一次 sequence number。</li>
</ol>
<p>最初，sequence number = 0，读线程不会修改 sequence number，而一个写线程会累加两次 sequence number，所以 sequence number 始终是偶数。如果 sequence number 是奇数，说明当前某个写线程正在修改数据，其他写线程被互斥。<br>对于写线程而言，发现 sequence number 是奇数，就不能修改共享数据了。对于读线程而言，发现 sequence number 是奇数，也不能再读取数据；如果发现 sequence number 是偶数，那么在读取数据前后分别读取一次 sequence number，如果两次的值相同，则读取成功，否则重新读取。</p>
<h3 id="7-7-2-scanGuard-解析"><a href="#7-7-2-scanGuard-解析" class="headerlink" title="7.7.2 scanGuard 解析"></a>7.7.2 scanGuard 解析</h3><p>scanGuard 变量充当了顺序锁的 sequence number 的功能，共享数据就是 Worker 线程数组 ws。所以，在scan 函数中，在函数开始的时候，读取了一次 scanGuard，扫描完 ws 对应的队列，又读取了一次 scanGuard，发现两次的值不同。说明在这期间 ws 的数组发生了变化，可能是新加了线程，ws 数组扩容了，于是返回false，重新进入 scan 函数。</p>
<h2 id="7-8-ForkJoinTask-的-fork-join"><a href="#7-8-ForkJoinTask-的-fork-join" class="headerlink" title="7.8 ForkJoinTask 的 fork/join"></a>7.8 ForkJoinTask 的 fork/join</h2><h3 id="7-8-1-fork"><a href="#7-8-1-fork" class="headerlink" title="7.8.1 fork"></a>7.8.1 fork</h3><h3 id="7-8-2-join-的层层嵌套"><a href="#7-8-2-join-的层层嵌套" class="headerlink" title="7.8.2 join 的层层嵌套"></a>7.8.2 join 的层层嵌套</h3><h2 id="7-9-ForkJoinPool-的优雅关闭"><a href="#7-9-ForkJoinPool-的优雅关闭" class="headerlink" title="7.9 ForkJoinPool 的优雅关闭"></a>7.9 ForkJoinPool 的优雅关闭</h2><h3 id="7-9-1-关键的-terminate-变量"><a href="#7-9-1-关键的-terminate-变量" class="headerlink" title="7.9.1 关键的 terminate 变量"></a>7.9.1 关键的 terminate 变量</h3><h3 id="7-9-2-shutdown-与-shutdownNow-的区别"><a href="#7-9-2-shutdown-与-shutdownNow-的区别" class="headerlink" title="7.9.2 shutdown() 与 shutdownNow() 的区别"></a>7.9.2 shutdown() 与 shutdownNow() 的区别</h3><p>shutdown() 只拒绝新提交的任务； shutdownNow() 会取消现有的全局队列和局部队列中的任务，同时唤醒所有空闲的线程，让这些线程自动退出。</p>
<h1 id="第八章-CompletableFuture"><a href="#第八章-CompletableFuture" class="headerlink" title="第八章 CompletableFuture"></a>第八章 CompletableFuture</h1><h2 id="8-1-CompletableFuture-用法"><a href="#8-1-CompletableFuture-用法" class="headerlink" title="8.1 CompletableFuture 用法"></a>8.1 CompletableFuture 用法</h2><h3 id="8-1-1-最简单的用法"><a href="#8-1-1-最简单的用法" class="headerlink" title="8.1.1 最简单的用法"></a>8.1.1 最简单的用法</h3><p>CompletableFuture 实现了 Future 接口，所以它也具有 Future 的特性：调用 get() 方法会阻塞在那，知道结果返回。</p>
<h3 id="8-1-2-提交任务：runAsync-与-supplyAsync"><a href="#8-1-2-提交任务：runAsync-与-supplyAsync" class="headerlink" title="8.1.2 提交任务：runAsync 与 supplyAsync"></a>8.1.2 提交任务：runAsync 与 supplyAsync</h3><p>CompletableFuture 和 Future 很相似，都可以提交两类任务：一类是无返回值的，另一类是有返回值的。</p>
<h3 id="8-1-3-链式的-CompletableFuture：thenRun、thenAccept-和-thenApply"><a href="#8-1-3-链式的-CompletableFuture：thenRun、thenAccept-和-thenApply" class="headerlink" title="8.1.3 链式的 CompletableFuture：thenRun、thenAccept 和 thenApply"></a>8.1.3 链式的 CompletableFuture：thenRun、thenAccept 和 thenApply</h3><p>对于 Future，在提交任务之后，只能调用 get() 等结果返回；但对于CompletableFuture，可以在结果上面加一个 callback，当得到结果之后，再接着执行 callback。<br>最后紧急执行 callback 的区别：</p>
<ol>
<li><p>thenRun 后面跟的是一个无参数、无返回值的方法，即 Runnable，所以最终的返回值是 CompletableFuture<void> 类型。</void></p>
</li>
<li><p>thenAccept 后main跟的是一个有参数、无返回值的方法，称为 Consumer，返回值也是CompletableFuture<void> 类型。顾名思义，只进不出，所以称为 Consumer；前面的 Supplier，是无参数，有返回值，只出不进，和 Consumer 刚好相反。</void></p>
</li>
<li><p>thenApply 后面跟的是一个有参数、有返回值的方法，称为 Function。返回值是 CompletableFuture<string> 类型。</string></p>
<h3 id="8-1-4-CompletableFuture-的组合：thenCompose-与-thenCombine"><a href="#8-1-4-CompletableFuture-的组合：thenCompose-与-thenCombine" class="headerlink" title="8.1.4 CompletableFuture 的组合：thenCompose 与 thenCombine"></a>8.1.4 CompletableFuture 的组合：thenCompose 与 thenCombine</h3><h3 id="8-1-5-任意个-CompletableFuture-的组合"><a href="#8-1-5-任意个-CompletableFuture-的组合" class="headerlink" title="8.1.5 任意个 CompletableFuture 的组合"></a>8.1.5 任意个 CompletableFuture 的组合</h3><p>thenCompose 与 thenCombine 只能组合2个 CompletableFuture，而 allof 和anyof 可以组合任意多个 CompletableFuture。这个两个函数都是静态函数，参数是变长的 CompletableFuture 的集合，allof 是与，anyof 是或</p>
<h2 id="8-2-四种任务原型"><a href="#8-2-四种任务原型" class="headerlink" title="8.2 四种任务原型"></a>8.2 四种任务原型</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2359192/1628527881616-ac2df675-70dd-4fc3-99c2-c544628b8532.png#align=left&amp;display=inline&amp;height=158&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=316&amp;originWidth=2054&amp;size=68706&amp;status=done&amp;style=none&amp;width=1027" alt="image.png"><br>runAsync 与 supplierAsync 是 CompletableFuture 的静态方法；而 thenAccept、runAsync、thenApply 是 CompletableFuture 的成员方法。<br>因为初始的时候没有 CompletableFuture 对象，也没有参数可传，所以提交的只能是 Runnable 或者 Supplier，只能是静态方法；<br>通过静态方法生成 CompletableFuture 对象之后，便可以链式地提交其他任务了，这个时候就可以提交 Runnable、Consumer、Function，且都是成员方法。</p>
<h2 id="8-3-CompletionFuture-接口"><a href="#8-3-CompletionFuture-接口" class="headerlink" title="8.3 CompletionFuture 接口"></a>8.3 CompletionFuture 接口</h2><h2 id="8-4-CompletableFuture-内部原理"><a href="#8-4-CompletableFuture-内部原理" class="headerlink" title="8.4 CompletableFuture 内部原理"></a>8.4 CompletableFuture 内部原理</h2><h3 id="8-4-1-CompletableFuture-的构造：ForkJoinPool"><a href="#8-4-1-CompletableFuture-的构造：ForkJoinPool" class="headerlink" title="8.4.1 CompletableFuture 的构造：ForkJoinPool"></a>8.4.1 CompletableFuture 的构造：ForkJoinPool</h3><p>asyncPool 是一个 static类型，supplierAsync、asyncSupplyStage 都是 static 函数。Static 函数返回一个 CompletableFuture 类型对象，之后可以链式调用，CompletionStage 里面的各个方法。</p>
<h3 id="8-4-2-任务类型的适配"><a href="#8-4-2-任务类型的适配" class="headerlink" title="8.4.2 任务类型的适配"></a>8.4.2 任务类型的适配</h3><h3 id="8-4-3-任务的链式执行过程分析"><a href="#8-4-3-任务的链式执行过程分析" class="headerlink" title="8.4.3 任务的链式执行过程分析"></a>8.4.3 任务的链式执行过程分析</h3><p>AsyncSupply 三个关键点：</p>
</li>
<li><p>继承自 ForkJoinTask，所以能够提交ForkJoinPool 来执行</p>
</li>
<li><p>封装了 Supplier f，即它所执行任务的具体内容</p>
</li>
<li><p>该任务的返回值，即 CompletableFuture d，也被封装在里面。</p>
</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">QuricoLouis</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://QuricoLouis.github.io/posts/cd039684.html">http://QuricoLouis.github.io/posts/cd039684.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">QuricoLouis</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                                <a href="/tags/JDK%E6%BA%90%E7%A0%81/">
                                    <span class="chip bg-color">JDK源码</span>
                                </a>
                            
                                <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
                                    <span class="chip bg-color">读书笔记</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo,twitter,facebook,google,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/QuricoLouis/imgBed/blog/20210801211316.JPG" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/QuricoLouis/imgBed/blog/20210801211325.JPG" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    .v[data-class="v"] .vwrap .vheader .vinput {
      width: 32%;
      border-bottom: 1px dashed #dedede;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
let metaPlaceholder = {"nick":"昵称/QQ号(必填)","mail":"邮箱(必填)","link":"网址(https://)"} ;
//这里要换行
new Valine({
        el: '#vcomments',
        appId: 'pSSgDom6mJ9UooJFVG0BETbt-gzGzoHsz',
        appKey: 'cXj7oyaGtm1p2QQEskba4SuV',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'monsterid',
        pageSize: '10',
        lang: 'zh-CN',
        placeholder: '留下你的足迹..',
        meta: ["nick", "mail", "link"],
        recordIP: 'true' === 'true',
        enableQQ: 'monsterid',
        requiredFields: ["d8192b4748c8fe9b6833f900b5b62f78"],
        master: ["d8192b4748c8fe9b6833f900b5b62f78"],
        friends: ["cb3e577ff029d6073400d5557effd41f"],
        tagMeta: ["博主", "小伙伴", "访客"],
        metaPlaceholder: metaPlaceholder,

    });

    document.body.addEventListener('click', function(e) {
        if (e.target.classList.contains('vsubmit')) {
            const email = document.querySelector('input[type=email]');
            const nick = document.querySelector('input[name=nick]');
            const reg = /^[A-Za-z0-9_-\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/;
            if (!email.value || !nick.value || !reg.test(email.value)) {
                const str = `<div class="valert txt-center"><div class="vtext">请填写正确的昵称和邮箱！</div></div>`;
                const vmark = document.querySelector('.vmark');
                vmark.innerHTML = str;
                vmark.style.display = 'block';

                e.stopPropagation();

                setTimeout(function() {
                    vmark.style.display = 'none';
                    vmark.innerHTML = '';
                }, 2500);
            }
        }
        }, true);
</script>



    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/59472fd8.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200928020407.jpg" class="responsive-img" alt="负载均衡原理及算法">
                        
                        <span class="card-title">负载均衡原理及算法</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            负载均衡原理及算法学习笔记
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-09-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" class="post-category">
                                    面试笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/">
                        <span class="chip bg-color">面试笔记</span>
                    </a>
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">
                        <span class="chip bg-color">分布式</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/5bd9b965.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200928013251.png" class="responsive-img" alt="Git笔记">
                        
                        <span class="card-title">Git笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            总结的Git笔记。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-05-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" class="post-category">
                                    面试笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Git/">
                        <span class="chip bg-color">Git</span>
                    </a>
                    
                    <a href="/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/">
                        <span class="chip bg-color">面试笔记</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: QuricoLouis<br />'
            + '文章作者: QuricoLouis<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="tencent"
                   type="playlist"
                   id="1776127550"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">QuricoLouis</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">23.1k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "7";
                    var startDate = "17";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/QuricoLouis/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:lq844040753@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=844040753" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 844040753" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/5714476659" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/5714476659" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/QuricoLouis" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/QuricoLouis" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.11/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?bfa6a2fd03ad7faf8f1fa72aba73ef1b";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

<!-- 深色模式按钮 -->
    <script>
        if (localStorage.getItem('dark') === '1') {
        document.body.classList.add('dark');
        }
        else if (new Date().getHours() >= 22 || new Date().getHours() < 7) {
        document.body.classList.add('dark');
        } 
        else if (matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
        }
    </script>
    <a onclick="switchNightMode()" id="sma">
        <i class="fas fa-lightbulb" id="nightMode" aria-hidden="true"></i>
    </a>

    <!-- 天气接口控件   -->
    
        <script type="text/javascript">
        WIDGET = {FID: 'zLkJSQpqsh'}
        </script>
    <!-- <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script> -->

    <script type="text/javascript">
      var windowWidth = $(window).width();
      if (windowWidth > 768) {
          document.write('<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"><\/script>');
      }
    </script>
    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: "79bfe73c"
        });
        daovoice('update');
    </script>
    

	
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
